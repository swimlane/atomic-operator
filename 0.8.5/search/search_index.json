{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"atomic-operator This python package is used to execute Atomic Red Team tests (Atomics) across multiple operating system environments. ( What's new? ) Why? atomic-operator enables security professionals to test their detection and defensive capabilities against prescribed techniques defined within atomic-red-team . By utilizing a testing framework such as atomic-operator , you can identify both your defensive capabilities as well as gaps in defensive coverage. Additionally, atomic-operator can be used in many other situations like: Generating alerts to test products Testing EDR and other security tools Identifying way to perform defensive evasion from an adversary perspective Plus more. Features Support local and remote execution of Atomic Red Teams tests on Windows, macOS, and Linux systems Supports running atomic-tests against iaas:aws Can prompt for input arguments but not required Assist with downloading the atomic-red-team repository Can be automated further based on a configuration file A command-line and importable Python package Select specific tests when one or more techniques are specified Plus more Getting Started atomic-operator is a Python-only package hosted on PyPi and works with Python 3.6 and greater. If you are wanting a PowerShell version, please checkout Invoke-AtomicRedTeam . pip install atomic-operator The next steps will guide you through setting up and running atomic-operator . Get Atomics Install / clone Atomic Red Team repository atomic-operator Understand the options availble in atomic-operator Running Test on Command Line or Running Tests within a Script Running Tests via Configuration File Installation You can install atomic-operator on OS X, Linux, or Windows. You can also install it directly from the source. To install, see the commands under the relevant operating system heading, below. Prerequisites The following libraries are required and installed by atomic-operator: pyyaml==5.4.1 fire==0.4.0 requests==2.26.0 attrs==21.2.0 pick==1.2.0 macOS, Linux and Windows: pip install atomic-operator macOS using M1 processor git clone https://github.com/swimlane/atomic-operator.git cd atomic-operator # Satisfy ModuleNotFoundError: No module named 'setuptools_rust' brew install rust pip3 install --upgrade pip pip3 install setuptools_rust # Back to our regularly scheduled programming . . . pip install -r requirements.txt python setup.py install Installing from source git clone https://github.com/swimlane/atomic-operator.git cd atomic-operator pip install -r requirements.txt python setup.py install Usage example (command line) You can run atomic-operator from the command line or within your own Python scripts. To use atomic-operator at the command line simply enter the following in your terminal: atomic-operator --help atomic-operator run -- --help Please note that to see details about the run command run atomic-operator run -- --help and NOT atomic-operator run --help Retrieving Atomic Tests In order to use atomic-operator you must have one or more atomic-red-team tests (Atomics) on your local system. atomic-operator provides you with the ability to download the Atomic Red Team repository. You can do so by running the following at the command line: atomic-operator get_atomics # You can specify the destination directory by using the --destination flag atomic-operator get_atomics --destination \"/tmp/some_directory\" Running Tests Locally In order to run a test you must provide some additional properties (and options if desired). The main method to run tests is named run . # This will run ALL tests compatiable with your local operating system atomic-operator run --atomics-path \"/tmp/some_directory/redcanaryco-atomic-red-team-3700624\" You can select individual tests when you provide one or more specific techniques. For example running the following on the command line: atomic-operator run --techniques T1564.001 --select_tests Will prompt the user with a selection list of tests associated with that technique. A user can select one or more tests by using the space bar to highlight the desired test: Select Test(s) for Technique T1564.001 (Hide Artifacts: Hidden Files and Directories) * Create a hidden file in a hidden directory (61a782e5-9a19-40b5-8ba4-69a4b9f3d7be) Mac Hidden file (cddb9098-3b47-4e01-9d3b-6f5f323288a9) Create Windows System File with Attrib (f70974c8-c094-4574-b542-2c545af95a32) Create Windows Hidden File with Attrib (dadb792e-4358-4d8d-9207-b771faa0daa5) Hidden files (3b7015f2-3144-4205-b799-b05580621379) Hide a Directory (b115ecaf-3b24-4ed2-aefe-2fcb9db913d3) Show all hidden files (9a1ec7da-b892-449f-ad68-67066d04380c) Running Tests Remotely In order to run a test remotely you must provide some additional properties (and options if desired). The main method to run tests is named run . # This will run ALL tests compatiable with your local operating system atomic-operator run --atomics-path \"/tmp/some_directory/redcanaryco-atomic-red-team-3700624\" --hosts \"10.32.1.0\" --username \"my_username\" --password \"my_password\" When running commands remotely against Windows hosts you may need to configure PSRemoting. See details here: Windows Remoting Additional parameters You can see additional parameters by running the following command: atomic-operator run -- --help Parameter Name Type Default Description techniques list all One or more defined techniques by attack_technique ID. test_guids list None One or more Atomic test GUIDs. select_tests bool False Select one or more atomic tests to run when a techniques are specified. atomics_path str os.getcwd() The path of Atomic tests. check_prereqs bool False Whether or not to check for prereq dependencies (prereq_comand). get_prereqs bool False Whether or not you want to retrieve prerequisites. cleanup bool False Whether or not you want to run cleanup command(s). copy_source_files bool True Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. command_timeout int 20 Time duration for each command before timeout. debug bool False Whether or not you want to output details about tests being ran. prompt_for_input_args bool False Whether you want to prompt for input arguments for each test. return_atomics bool False Whether or not you want to return atomics instead of running them. config_file str None A path to a conifg_file which is used to automate atomic-operator in environments. config_file_only bool False Whether or not you want to run tests based on the provided config_file only. hosts list None A list of one or more remote hosts to run a test on. username str None Username for authentication of remote connections. password str None Password for authentication of remote connections. ssh_key_path str None Path to a SSH Key for authentication of remote connections. private_key_string str None A private SSH Key string used for authentication of remote connections. verify_ssl bool False Whether or not to verify ssl when connecting over RDP (windows). ssh_port int 22 SSH port for authentication of remote connections. ssh_timeout int 5 SSH timeout for authentication of remote connections. **kwargs dict None If additional flags are passed into the run command then we will attempt to match them with defined inputs within Atomic tests and replace their value with the provided value. You should see a similar output to the following: NAME atomic-operator run - The main method in which we run Atomic Red Team tests. SYNOPSIS atomic-operator run <flags> DESCRIPTION The main method in which we run Atomic Red Team tests. FLAGS --techniques=TECHNIQUES Type: list Default: ['all'] One or more defined techniques by attack_technique ID. Defaults to 'all'. --test_guids=TEST_GUIDS Type: list Default: [] One or more Atomic test GUIDs. Defaults to None. --select_tests=SELECT_TESTS Type: bool Default: False Select one or more tests from provided techniques. Defaults to False. --atomics_path=ATOMICS_PATH Default: '/U... The path of Atomic tests. Defaults to os.getcwd(). --check_prereqs=CHECK_PREREQS Default: False Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. --get_prereqs=GET_PREREQS Default: False Whether or not you want to retrieve prerequisites. Defaults to False. --cleanup=CLEANUP Default: False Whether or not you want to run cleanup command(s). Defaults to False. --copy_source_files=COPY_SOURCE_FILES Default: True Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. --command_timeout=COMMAND_TIMEOUT Default: 20 Timeout duration for each command. Defaults to 20. --debug=DEBUG Default: False Whether or not you want to output details about tests being ran. Defaults to False. --prompt_for_input_args=PROMPT_FOR_INPUT_ARGS Default: False Whether you want to prompt for input arguments for each test. Defaults to False. --return_atomics=RETURN_ATOMICS Default: False Whether or not you want to return atomics instead of running them. Defaults to False. --config_file=CONFIG_FILE Type: Optional[] Default: None A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. --config_file_only=CONFIG_FILE_ONLY Default: False Whether or not you want to run tests based on the provided config_file only. Defaults to False. --hosts=HOSTS Default: [] A list of one or more remote hosts to run a test on. Defaults to []. --username=USERNAME Type: Optional[] Default: None Username for authentication of remote connections. Defaults to None. --password=PASSWORD Type: Optional[] Default: None Password for authentication of remote connections. Defaults to None. --ssh_key_path=SSH_KEY_PATH Type: Optional[] Default: None Path to a SSH Key for authentication of remote connections. Defaults to None. --private_key_string=PRIVATE_KEY_STRING Type: Optional[] Default: None A private SSH Key string used for authentication of remote connections. Defaults to None. --verify_ssl=VERIFY_SSL Default: False Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. --ssh_port=SSH_PORT Default: 22 SSH port for authentication of remote connections. Defaults to 22. --ssh_timeout=SSH_TIMEOUT Default: 5 SSH timeout for authentication of remote connections. Defaults to 5. Additional flags are accepted. If provided, keys matching inputs for a test will be replaced. Default is None. Running atomic-operator using a config_file In addition to the ability to pass in parameters with atomic-operator you can also pass in a path to a config_file that contains all the atomic tests and their potential inputs. You can see an example of this config_file here: atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2 Usage example (scripts) To use atomic-operator you must instantiate an AtomicOperator object. from atomic_operator import AtomicOperator operator = AtomicOperator() # This will download a local copy of the atomic-red-team repository print(operator.get_atomics('/tmp/some_directory')) # this will run tests on your local system operator.run( technique: str='All', atomics_path=os.getcwd(), check_dependencies=False, get_prereqs=False, cleanup=False, command_timeout=20, debug=False, prompt_for_input_args=False, **kwargs ) Getting Help Please create an issue if you have questions or run into any issues. Built With carcass - Python packaging template Contributing Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us. Versioning We use SemVer for versioning. Authors Josh Rickard - Initial work - MSAdministrator See also the list of contributors who participated in this project. License This project is licensed under the MIT License - see the LICENSE file for details Shoutout Thanks to keithmccammon for helping identify issues with macOS M1 based proccesssor and providing a fix","title":"Home"},{"location":"#atomic-operator","text":"This python package is used to execute Atomic Red Team tests (Atomics) across multiple operating system environments. ( What's new? )","title":"atomic-operator"},{"location":"#why","text":"atomic-operator enables security professionals to test their detection and defensive capabilities against prescribed techniques defined within atomic-red-team . By utilizing a testing framework such as atomic-operator , you can identify both your defensive capabilities as well as gaps in defensive coverage. Additionally, atomic-operator can be used in many other situations like: Generating alerts to test products Testing EDR and other security tools Identifying way to perform defensive evasion from an adversary perspective Plus more.","title":"Why?"},{"location":"#features","text":"Support local and remote execution of Atomic Red Teams tests on Windows, macOS, and Linux systems Supports running atomic-tests against iaas:aws Can prompt for input arguments but not required Assist with downloading the atomic-red-team repository Can be automated further based on a configuration file A command-line and importable Python package Select specific tests when one or more techniques are specified Plus more","title":"Features"},{"location":"#getting-started","text":"atomic-operator is a Python-only package hosted on PyPi and works with Python 3.6 and greater. If you are wanting a PowerShell version, please checkout Invoke-AtomicRedTeam . pip install atomic-operator The next steps will guide you through setting up and running atomic-operator . Get Atomics Install / clone Atomic Red Team repository atomic-operator Understand the options availble in atomic-operator Running Test on Command Line or Running Tests within a Script Running Tests via Configuration File","title":"Getting Started"},{"location":"#installation","text":"You can install atomic-operator on OS X, Linux, or Windows. You can also install it directly from the source. To install, see the commands under the relevant operating system heading, below.","title":"Installation"},{"location":"#prerequisites","text":"The following libraries are required and installed by atomic-operator: pyyaml==5.4.1 fire==0.4.0 requests==2.26.0 attrs==21.2.0 pick==1.2.0","title":"Prerequisites"},{"location":"#macos-linux-and-windows","text":"pip install atomic-operator","title":"macOS, Linux and Windows:"},{"location":"#macos-using-m1-processor","text":"git clone https://github.com/swimlane/atomic-operator.git cd atomic-operator # Satisfy ModuleNotFoundError: No module named 'setuptools_rust' brew install rust pip3 install --upgrade pip pip3 install setuptools_rust # Back to our regularly scheduled programming . . . pip install -r requirements.txt python setup.py install","title":"macOS using M1 processor"},{"location":"#installing-from-source","text":"git clone https://github.com/swimlane/atomic-operator.git cd atomic-operator pip install -r requirements.txt python setup.py install","title":"Installing from source"},{"location":"#usage-example-command-line","text":"You can run atomic-operator from the command line or within your own Python scripts. To use atomic-operator at the command line simply enter the following in your terminal: atomic-operator --help atomic-operator run -- --help Please note that to see details about the run command run atomic-operator run -- --help and NOT atomic-operator run --help","title":"Usage example (command line)"},{"location":"#retrieving-atomic-tests","text":"In order to use atomic-operator you must have one or more atomic-red-team tests (Atomics) on your local system. atomic-operator provides you with the ability to download the Atomic Red Team repository. You can do so by running the following at the command line: atomic-operator get_atomics # You can specify the destination directory by using the --destination flag atomic-operator get_atomics --destination \"/tmp/some_directory\"","title":"Retrieving Atomic Tests"},{"location":"#running-tests-locally","text":"In order to run a test you must provide some additional properties (and options if desired). The main method to run tests is named run . # This will run ALL tests compatiable with your local operating system atomic-operator run --atomics-path \"/tmp/some_directory/redcanaryco-atomic-red-team-3700624\" You can select individual tests when you provide one or more specific techniques. For example running the following on the command line: atomic-operator run --techniques T1564.001 --select_tests Will prompt the user with a selection list of tests associated with that technique. A user can select one or more tests by using the space bar to highlight the desired test: Select Test(s) for Technique T1564.001 (Hide Artifacts: Hidden Files and Directories) * Create a hidden file in a hidden directory (61a782e5-9a19-40b5-8ba4-69a4b9f3d7be) Mac Hidden file (cddb9098-3b47-4e01-9d3b-6f5f323288a9) Create Windows System File with Attrib (f70974c8-c094-4574-b542-2c545af95a32) Create Windows Hidden File with Attrib (dadb792e-4358-4d8d-9207-b771faa0daa5) Hidden files (3b7015f2-3144-4205-b799-b05580621379) Hide a Directory (b115ecaf-3b24-4ed2-aefe-2fcb9db913d3) Show all hidden files (9a1ec7da-b892-449f-ad68-67066d04380c)","title":"Running Tests Locally"},{"location":"#running-tests-remotely","text":"In order to run a test remotely you must provide some additional properties (and options if desired). The main method to run tests is named run . # This will run ALL tests compatiable with your local operating system atomic-operator run --atomics-path \"/tmp/some_directory/redcanaryco-atomic-red-team-3700624\" --hosts \"10.32.1.0\" --username \"my_username\" --password \"my_password\" When running commands remotely against Windows hosts you may need to configure PSRemoting. See details here: Windows Remoting","title":"Running Tests Remotely"},{"location":"#additional-parameters","text":"You can see additional parameters by running the following command: atomic-operator run -- --help Parameter Name Type Default Description techniques list all One or more defined techniques by attack_technique ID. test_guids list None One or more Atomic test GUIDs. select_tests bool False Select one or more atomic tests to run when a techniques are specified. atomics_path str os.getcwd() The path of Atomic tests. check_prereqs bool False Whether or not to check for prereq dependencies (prereq_comand). get_prereqs bool False Whether or not you want to retrieve prerequisites. cleanup bool False Whether or not you want to run cleanup command(s). copy_source_files bool True Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. command_timeout int 20 Time duration for each command before timeout. debug bool False Whether or not you want to output details about tests being ran. prompt_for_input_args bool False Whether you want to prompt for input arguments for each test. return_atomics bool False Whether or not you want to return atomics instead of running them. config_file str None A path to a conifg_file which is used to automate atomic-operator in environments. config_file_only bool False Whether or not you want to run tests based on the provided config_file only. hosts list None A list of one or more remote hosts to run a test on. username str None Username for authentication of remote connections. password str None Password for authentication of remote connections. ssh_key_path str None Path to a SSH Key for authentication of remote connections. private_key_string str None A private SSH Key string used for authentication of remote connections. verify_ssl bool False Whether or not to verify ssl when connecting over RDP (windows). ssh_port int 22 SSH port for authentication of remote connections. ssh_timeout int 5 SSH timeout for authentication of remote connections. **kwargs dict None If additional flags are passed into the run command then we will attempt to match them with defined inputs within Atomic tests and replace their value with the provided value. You should see a similar output to the following: NAME atomic-operator run - The main method in which we run Atomic Red Team tests. SYNOPSIS atomic-operator run <flags> DESCRIPTION The main method in which we run Atomic Red Team tests. FLAGS --techniques=TECHNIQUES Type: list Default: ['all'] One or more defined techniques by attack_technique ID. Defaults to 'all'. --test_guids=TEST_GUIDS Type: list Default: [] One or more Atomic test GUIDs. Defaults to None. --select_tests=SELECT_TESTS Type: bool Default: False Select one or more tests from provided techniques. Defaults to False. --atomics_path=ATOMICS_PATH Default: '/U... The path of Atomic tests. Defaults to os.getcwd(). --check_prereqs=CHECK_PREREQS Default: False Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. --get_prereqs=GET_PREREQS Default: False Whether or not you want to retrieve prerequisites. Defaults to False. --cleanup=CLEANUP Default: False Whether or not you want to run cleanup command(s). Defaults to False. --copy_source_files=COPY_SOURCE_FILES Default: True Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. --command_timeout=COMMAND_TIMEOUT Default: 20 Timeout duration for each command. Defaults to 20. --debug=DEBUG Default: False Whether or not you want to output details about tests being ran. Defaults to False. --prompt_for_input_args=PROMPT_FOR_INPUT_ARGS Default: False Whether you want to prompt for input arguments for each test. Defaults to False. --return_atomics=RETURN_ATOMICS Default: False Whether or not you want to return atomics instead of running them. Defaults to False. --config_file=CONFIG_FILE Type: Optional[] Default: None A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. --config_file_only=CONFIG_FILE_ONLY Default: False Whether or not you want to run tests based on the provided config_file only. Defaults to False. --hosts=HOSTS Default: [] A list of one or more remote hosts to run a test on. Defaults to []. --username=USERNAME Type: Optional[] Default: None Username for authentication of remote connections. Defaults to None. --password=PASSWORD Type: Optional[] Default: None Password for authentication of remote connections. Defaults to None. --ssh_key_path=SSH_KEY_PATH Type: Optional[] Default: None Path to a SSH Key for authentication of remote connections. Defaults to None. --private_key_string=PRIVATE_KEY_STRING Type: Optional[] Default: None A private SSH Key string used for authentication of remote connections. Defaults to None. --verify_ssl=VERIFY_SSL Default: False Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. --ssh_port=SSH_PORT Default: 22 SSH port for authentication of remote connections. Defaults to 22. --ssh_timeout=SSH_TIMEOUT Default: 5 SSH timeout for authentication of remote connections. Defaults to 5. Additional flags are accepted. If provided, keys matching inputs for a test will be replaced. Default is None.","title":"Additional parameters"},{"location":"#running-atomic-operator-using-a-config_file","text":"In addition to the ability to pass in parameters with atomic-operator you can also pass in a path to a config_file that contains all the atomic tests and their potential inputs. You can see an example of this config_file here: atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2","title":"Running atomic-operator using a config_file"},{"location":"#usage-example-scripts","text":"To use atomic-operator you must instantiate an AtomicOperator object. from atomic_operator import AtomicOperator operator = AtomicOperator() # This will download a local copy of the atomic-red-team repository print(operator.get_atomics('/tmp/some_directory')) # this will run tests on your local system operator.run( technique: str='All', atomics_path=os.getcwd(), check_dependencies=False, get_prereqs=False, cleanup=False, command_timeout=20, debug=False, prompt_for_input_args=False, **kwargs )","title":"Usage example (scripts)"},{"location":"#getting-help","text":"Please create an issue if you have questions or run into any issues.","title":"Getting Help"},{"location":"#built-with","text":"carcass - Python packaging template","title":"Built With"},{"location":"#contributing","text":"Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us.","title":"Contributing"},{"location":"#versioning","text":"We use SemVer for versioning.","title":"Versioning"},{"location":"#authors","text":"Josh Rickard - Initial work - MSAdministrator See also the list of contributors who participated in this project.","title":"Authors"},{"location":"#license","text":"This project is licensed under the MIT License - see the LICENSE file for details","title":"License"},{"location":"#shoutout","text":"Thanks to keithmccammon for helping identify issues with macOS M1 based proccesssor and providing a fix","title":"Shoutout"},{"location":"CHANGELOG/","text":"CHANGELOG 0.8.4 - 2022-03-25 * Updated formatting of executor for AWS and local runners * Updated documentation * Added formatting constants to base class to improve updating of windows variables on command line runners 0.7.0 - 2022-01-04 * Updated argument handling in get_atomics Retrieving Atomic Tests with specified destination in /opt throws unexpected keyword argument error #28 * Updated error catching and logging within state machine class when copying source files to remote system Logging and troubleshooting question #32 * Updated ConfigParser from instance variables to local method bound variables Using a second AtomicOperator instance executes the tests of the first instance too #33 * Added the ability to select specific tests for one or more provided techniques * Updated documentation * Added new Copier class to handle file transfer for remote connections * Removed gathering of supporting_files and passing around with object * Added new config_file_only parameter to only run the defined configuration within a configuration file * Updated documentation around installation on macOS systems with M1 processors 0.6.0 - 2021-12-17 * Updated documentation * Added better handling of help 0.5.1 - 2021-11-18 * Updating handling of passing --help to the run command * Updated docs to reflect change 0.5.0 - 2021-11-18 * Updated handling of versioning * Updated CI to handle versioning of docs and deployment on release * Added better handling of extracting zip file * Added safer loading of yaml files * Update docs * Improved logging across the board and implemented a debug switch 0.4.0 - 2021-11-15 * Added support for transferring files during remote execution * Refactored config handling * Updated docs and githubpages 0.2.0 - 2021-10-05 * Added support for remote execution of atomic-tests * Added support for executing iaas:aws tests * Added configuration support * Plus many other features 0.0.1 - 2021-07-26 Initial release","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#084-2022-03-25","text":"* Updated formatting of executor for AWS and local runners * Updated documentation * Added formatting constants to base class to improve updating of windows variables on command line runners","title":"0.8.4 - 2022-03-25"},{"location":"CHANGELOG/#070-2022-01-04","text":"* Updated argument handling in get_atomics Retrieving Atomic Tests with specified destination in /opt throws unexpected keyword argument error #28 * Updated error catching and logging within state machine class when copying source files to remote system Logging and troubleshooting question #32 * Updated ConfigParser from instance variables to local method bound variables Using a second AtomicOperator instance executes the tests of the first instance too #33 * Added the ability to select specific tests for one or more provided techniques * Updated documentation * Added new Copier class to handle file transfer for remote connections * Removed gathering of supporting_files and passing around with object * Added new config_file_only parameter to only run the defined configuration within a configuration file * Updated documentation around installation on macOS systems with M1 processors","title":"0.7.0 - 2022-01-04"},{"location":"CHANGELOG/#060-2021-12-17","text":"* Updated documentation * Added better handling of help","title":"0.6.0 - 2021-12-17"},{"location":"CHANGELOG/#051-2021-11-18","text":"* Updating handling of passing --help to the run command * Updated docs to reflect change","title":"0.5.1 - 2021-11-18"},{"location":"CHANGELOG/#050-2021-11-18","text":"* Updated handling of versioning * Updated CI to handle versioning of docs and deployment on release * Added better handling of extracting zip file * Added safer loading of yaml files * Update docs * Improved logging across the board and implemented a debug switch","title":"0.5.0 - 2021-11-18"},{"location":"CHANGELOG/#040-2021-11-15","text":"* Added support for transferring files during remote execution * Refactored config handling * Updated docs and githubpages","title":"0.4.0 - 2021-11-15"},{"location":"CHANGELOG/#020-2021-10-05","text":"* Added support for remote execution of atomic-tests * Added support for executing iaas:aws tests * Added configuration support * Plus many other features","title":"0.2.0 - 2021-10-05"},{"location":"CHANGELOG/#001-2021-07-26","text":"Initial release","title":"0.0.1 - 2021-07-26"},{"location":"CONTRIBUTING/","text":"Contributing When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Please note we have a code of conduct, please follow it in all your interactions with the project. Pull Request Process Ensure any install or build dependencies are removed before the end of the layer when doing a build. Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters. Increase the version numbers in any examples files and the README.md to the new version that this Pull Request would represent. The versioning scheme we use is SemVer . You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you. Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [INSERT EMAIL ADDRESS]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Please note we have a code of conduct, please follow it in all your interactions with the project.","title":"Contributing"},{"location":"CONTRIBUTING/#pull-request-process","text":"Ensure any install or build dependencies are removed before the end of the layer when doing a build. Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters. Increase the version numbers in any examples files and the README.md to the new version that this Pull Request would represent. The versioning scheme we use is SemVer . You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you.","title":"Pull Request Process"},{"location":"CONTRIBUTING/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"CONTRIBUTING/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"CONTRIBUTING/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CONTRIBUTING/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"CONTRIBUTING/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CONTRIBUTING/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [INSERT EMAIL ADDRESS]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"CONTRIBUTING/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2021 Swimlane Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"atomic-operator-config/","text":"Configuration One feature of atomic-operator is the ability to automate running of Atomics even further via a configuration file. The configuration file supports many different layouts for configuration but the major features are: Define one or more Atomic tests by GUID You can provide values for any defined input arguments for an Atomic test You can assign an Atomic test to one or more inventory objects Define none, one, or more inventory objects An inventory is a collection of authentication properties as well as hosts associated with said authentication credentials With this structure you can create an inventory group of 1 or 100 hosts using a set of credentials and tell atomic-operator to run 1 or more tests with defined inputs against those hosts - infinitely flexible. Below is an example of all of these features implemented in a configuration file. inventory: windows1: executor: powershell # or cmd authentication: username: username password: some_passowrd! verify_ssl: false hosts: - 192.168.1.1 - 10.32.1.1 # etc linux1: executor: ssh authentication: username: username password: some_passowrd! #ssk_key_path: port: 22 timeout: 5 hosts: - 192.168.1.1 - 10.32.100.1 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt inventories: - windows1 - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument inventories: - windows1 - linux1 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17 inventories: - linux1 At the basic level of the configuration file you can simply just have one that defines a set of Atomic tests you want to run like so: atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17 You can also specify input variable values for one or more of them: atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17 But if you want to run them remotely then you must add in inventory objects with the correct credentials and one or more hosts: inventory: windows1: executor: powershell # or cmd authentication: username: username password: some_passowrd! verify_ssl: false hosts: - 192.168.1.1 - 10.32.1.1 atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt inventories: - windows1 - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17","title":"Running Tests via Configuration File"},{"location":"atomic-operator-config/#configuration","text":"One feature of atomic-operator is the ability to automate running of Atomics even further via a configuration file. The configuration file supports many different layouts for configuration but the major features are: Define one or more Atomic tests by GUID You can provide values for any defined input arguments for an Atomic test You can assign an Atomic test to one or more inventory objects Define none, one, or more inventory objects An inventory is a collection of authentication properties as well as hosts associated with said authentication credentials With this structure you can create an inventory group of 1 or 100 hosts using a set of credentials and tell atomic-operator to run 1 or more tests with defined inputs against those hosts - infinitely flexible. Below is an example of all of these features implemented in a configuration file. inventory: windows1: executor: powershell # or cmd authentication: username: username password: some_passowrd! verify_ssl: false hosts: - 192.168.1.1 - 10.32.1.1 # etc linux1: executor: ssh authentication: username: username password: some_passowrd! #ssk_key_path: port: 22 timeout: 5 hosts: - 192.168.1.1 - 10.32.100.1 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt inventories: - windows1 - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument inventories: - windows1 - linux1 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17 inventories: - linux1 At the basic level of the configuration file you can simply just have one that defines a set of Atomic tests you want to run like so: atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17 You can also specify input variable values for one or more of them: atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17 But if you want to run them remotely then you must add in inventory objects with the correct credentials and one or more hosts: inventory: windows1: executor: powershell # or cmd authentication: username: username password: some_passowrd! verify_ssl: false hosts: - 192.168.1.1 - 10.32.1.1 atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt inventories: - windows1 - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 - guid: c141bbdb-7fca-4254-9fd6-f47e79447e17","title":"Configuration"},{"location":"atomic-operator-ref/","text":"AtomicOperator Bases: Base Main class used to run Atomic Red Team tests. atomic-operator is used to run Atomic Red Team tests both locally and remotely. These tests (atomics) are predefined tests to mock or emulate a specific technique. config_file definition atomic-operator's run method can be supplied with a path to a configuration file (config_file) which defines specific tests and/or values for input parameters to facilitate automation of said tests. An example of this config_file can be seen below: inventory: linux1: executor: ssh authentication: username: root password: Somepassword! #ssk_key_path: port: 22 timeout: 5 hosts: # - 192.168.1.1 - 10.32.100.199 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2 inventories: - linux1 Raises: Type Description ValueError If a provided technique is unknown we raise an error. Source code in atomic_operator/atomic_operator.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class AtomicOperator ( Base ): \"\"\"Main class used to run Atomic Red Team tests. atomic-operator is used to run Atomic Red Team tests both locally and remotely. These tests (atomics) are predefined tests to mock or emulate a specific technique. config_file definition: atomic-operator's run method can be supplied with a path to a configuration file (config_file) which defines specific tests and/or values for input parameters to facilitate automation of said tests. An example of this config_file can be seen below: inventory: linux1: executor: ssh authentication: username: root password: Somepassword! #ssk_key_path: port: 22 timeout: 5 hosts: # - 192.168.1.1 - 10.32.100.199 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2 inventories: - linux1 Raises: ValueError: If a provided technique is unknown we raise an error. \"\"\" __test_responses = {} def __find_path ( self , value ): \"\"\"Attempts to find a path containing the atomic-red-team repository Args: value (str): A starting path to iterate through Returns: str: An absolute path containing the path to the atomic-red-team repo \"\"\" if value == os . getcwd (): for x in os . listdir ( value ): if os . path . isdir ( x ) and 'redcanaryco-atomic-red-team' in x : if os . path . exists ( self . get_abs_path ( os . path . join ( x , 'atomics' ))): return self . get_abs_path ( os . path . join ( x , 'atomics' )) else : if os . path . exists ( self . get_abs_path ( value )): return self . get_abs_path ( value ) def __check_arguments ( self , kwargs , method ): if kwargs : for arguments in inspect . getfullargspec ( method ): if isinstance ( arguments , list ): for arg in arguments : for key , val in kwargs . items (): if key in arg : return IncorrectParameters ( f \"You passed in an argument of ' { key } ' which is not recognized. Did you mean ' { arg } '?\" ) return IncorrectParameters ( f \"You passed in an argument of ' { key } ' which is not recognized.\" ) def __run_technique ( self , technique , ** kwargs ): \"\"\"This method is used to run defined Atomic tests within a MITRE ATT&CK Technique. Args: technique (Atomic): An Atomic object which contains a list of AtomicTest objects. \"\"\" self . __logger . debug ( f \"Checking technique { technique . attack_technique } ( { technique . display_name } ) for applicable tests.\" ) for test in technique . atomic_tests : self . _set_input_arguments ( test , ** kwargs ) if test . auto_generated_guid not in self . __test_responses : self . __test_responses [ test . auto_generated_guid ] = {} if technique . hosts : for host in technique . hosts : self . __logger . info ( f \"Running { test . name } test ( { test . auto_generated_guid } ) for technique { technique . attack_technique } \" ) self . __logger . debug ( f \"Description: { test . description } \" ) if test . executor . name in [ 'sh' , 'bash' ]: self . __test_responses [ test . auto_generated_guid ] . update ( RemoteRunner ( test , technique . path ) . start ( host = host , executor = 'ssh' ) ) elif test . executor . name in [ 'command_prompt' ]: self . __test_responses [ test . auto_generated_guid ] . update ( RemoteRunner ( test , technique . path ) . start ( host = host , executor = 'cmd' ) ) elif test . executor . name in [ 'powershell' ]: self . __test_responses [ test . auto_generated_guid ] . update ( RemoteRunner ( test , technique . path ) . start ( host = host , executor = 'powershell' ) ) else : self . __logger . warning ( f \"Unable to execute test since the executor is { test . executor . name } . Skipping.....\" ) else : if self . _check_platform ( test , show_output = True ): self . __logger . info ( f \"Running { test . name } test ( { test . auto_generated_guid } ) for technique { technique . attack_technique } \" ) self . __logger . debug ( f \"Description: { test . description } \" ) if self . _check_if_aws ( test ): self . __test_responses [ test . auto_generated_guid ] . update ( AWSRunner ( test , technique . path ) . start () ) else : self . __test_responses [ test . auto_generated_guid ] . update ( LocalRunner ( test , technique . path ) . start () ) if self . __test_responses . get ( test . auto_generated_guid ): self . __test_responses [ test . auto_generated_guid ] . update ({ 'technique_id' : technique . attack_technique , 'technique_name' : technique . display_name }) def help ( self , method = None ): from fire.trace import FireTrace from fire.helptext import HelpText obj = AtomicOperator if not method else getattr ( self , method ) return HelpText ( self . run , trace = FireTrace ( obj )) def get_atomics ( self , desintation = os . getcwd (), ** kwargs ): \"\"\"Downloads the RedCanary atomic-red-team repository to your local system. Args: desintation (str, optional): A folder path to download the repositorty data to. Defaults to os.getcwd(). kwargs (dict, optional): This kwargs will be passed along to Python requests library during download. Defaults to None. Returns: str: The path the data can be found at. \"\"\" if not os . path . exists ( desintation ): os . makedirs ( desintation ) desintation = kwargs . pop ( 'destination' ) if kwargs . get ( 'destination' ) else desintation folder_name = self . download_atomic_red_team_repo ( save_path = desintation , ** kwargs ) return os . path . join ( desintation , folder_name ) def run ( self , techniques : list = [ 'all' ], test_guids : list = [], select_tests = False , atomics_path = os . getcwd (), check_prereqs = False , get_prereqs = False , cleanup = False , copy_source_files = True , command_timeout = 20 , debug = False , prompt_for_input_args = False , return_atomics = False , config_file = None , config_file_only = False , hosts = [], username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , * args , ** kwargs ) -> None : \"\"\"The main method in which we run Atomic Red Team tests. Args: techniques (list, optional): One or more defined techniques by attack_technique ID. Defaults to 'all'. test_guids (list, optional): One or more Atomic test GUIDs. Defaults to None. select_tests (bool, optional): Select one or more tests from provided techniques. Defaults to False. atomics_path (str, optional): The path of Atomic tests. Defaults to os.getcwd(). check_prereqs (bool, optional): Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. get_prereqs (bool, optional): Whether or not you want to retrieve prerequisites. Defaults to False. cleanup (bool, optional): Whether or not you want to run cleanup command(s). Defaults to False. copy_source_files (bool, optional): Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. command_timeout (int, optional): Timeout duration for each command. Defaults to 20. debug (bool, optional): Whether or not you want to output details about tests being ran. Defaults to False. prompt_for_input_args (bool, optional): Whether you want to prompt for input arguments for each test. Defaults to False. return_atomics (bool, optional): Whether or not you want to return atomics instead of running them. Defaults to False. config_file (str, optional): A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. config_file_only (bool, optional): Whether or not you want to run tests based on the provided config_file only. Defaults to False. hosts (list, optional): A list of one or more remote hosts to run a test on. Defaults to []. username (str, optional): Username for authentication of remote connections. Defaults to None. password (str, optional): Password for authentication of remote connections. Defaults to None. ssh_key_path (str, optional): Path to a SSH Key for authentication of remote connections. Defaults to None. private_key_string (str, optional): A private SSH Key string used for authentication of remote connections. Defaults to None. verify_ssl (bool, optional): Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. ssh_port (int, optional): SSH port for authentication of remote connections. Defaults to 22. ssh_timeout (int, optional): SSH timeout for authentication of remote connections. Defaults to 5. kwargs (dict, optional): If provided, keys matching inputs for a test will be replaced. Default is None. Raises: ValueError: If a provided technique is unknown we raise an error. \"\"\" response = self . __check_arguments ( kwargs , self . run ) if response : return response if kwargs . get ( 'help' ): return self . help ( method = 'run' ) if debug : import logging logging . getLogger () . setLevel ( logging . DEBUG ) count = 0 if check_prereqs : count += 1 if get_prereqs : count += 1 if cleanup : count += 1 if count > 1 : return IncorrectParameters ( f \"You have passed in incompatible arguments. Please only provide one of 'check_prereqs','get_prereqs','cleanup'.\" ) atomics_path = self . __find_path ( atomics_path ) if not atomics_path : return AtomicsFolderNotFound ( 'Unable to find a folder containing Atomics. Please provide a path or run get_atomics.' ) Base . CONFIG = Config ( atomics_path = atomics_path , check_prereqs = check_prereqs , get_prereqs = get_prereqs , cleanup = cleanup , command_timeout = command_timeout , debug = debug , prompt_for_input_args = prompt_for_input_args , kwargs = kwargs , copy_source_files = copy_source_files ) # taking inputs from both config_file and passed in values via command # line to build a run_list of objects self . __config_parser = ConfigParser ( config_file = config_file , techniques = None if config_file_only else self . parse_input_lists ( techniques ), test_guids = None if config_file_only else self . parse_input_lists ( test_guids ), host_list = None if config_file_only else self . parse_input_lists ( hosts ), username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout , select_tests = select_tests ) self . __run_list = self . __config_parser . run_list __return_atomics = [] for item in self . __run_list : if return_atomics : __return_atomics . append ( item ) elif kwargs . get ( 'kwargs' ): self . __run_technique ( item , ** kwargs . get ( 'kwargs' )) else : self . __run_technique ( item ) if return_atomics and __return_atomics : return __return_atomics return self . __test_responses get_atomics ( desintation = os . getcwd (), ** kwargs ) Downloads the RedCanary atomic-red-team repository to your local system. Parameters: Name Type Description Default desintation str A folder path to download the repositorty data to. Defaults to os.getcwd(). os.getcwd() kwargs dict This kwargs will be passed along to Python requests library during download. Defaults to None. required Returns: Name Type Description str The path the data can be found at. Source code in atomic_operator/atomic_operator.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_atomics ( self , desintation = os . getcwd (), ** kwargs ): \"\"\"Downloads the RedCanary atomic-red-team repository to your local system. Args: desintation (str, optional): A folder path to download the repositorty data to. Defaults to os.getcwd(). kwargs (dict, optional): This kwargs will be passed along to Python requests library during download. Defaults to None. Returns: str: The path the data can be found at. \"\"\" if not os . path . exists ( desintation ): os . makedirs ( desintation ) desintation = kwargs . pop ( 'destination' ) if kwargs . get ( 'destination' ) else desintation folder_name = self . download_atomic_red_team_repo ( save_path = desintation , ** kwargs ) return os . path . join ( desintation , folder_name ) run ( techniques = [ 'all' ], test_guids = [], select_tests = False , atomics_path = os . getcwd (), check_prereqs = False , get_prereqs = False , cleanup = False , copy_source_files = True , command_timeout = 20 , debug = False , prompt_for_input_args = False , return_atomics = False , config_file = None , config_file_only = False , hosts = [], username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , * args , ** kwargs ) The main method in which we run Atomic Red Team tests. Parameters: Name Type Description Default techniques list One or more defined techniques by attack_technique ID. Defaults to 'all'. ['all'] test_guids list One or more Atomic test GUIDs. Defaults to None. [] select_tests bool Select one or more tests from provided techniques. Defaults to False. False atomics_path str The path of Atomic tests. Defaults to os.getcwd(). os.getcwd() check_prereqs bool Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. False get_prereqs bool Whether or not you want to retrieve prerequisites. Defaults to False. False cleanup bool Whether or not you want to run cleanup command(s). Defaults to False. False copy_source_files bool Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. True command_timeout int Timeout duration for each command. Defaults to 20. 20 debug bool Whether or not you want to output details about tests being ran. Defaults to False. False prompt_for_input_args bool Whether you want to prompt for input arguments for each test. Defaults to False. False return_atomics bool Whether or not you want to return atomics instead of running them. Defaults to False. False config_file str A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. None config_file_only bool Whether or not you want to run tests based on the provided config_file only. Defaults to False. False hosts list A list of one or more remote hosts to run a test on. Defaults to []. [] username str Username for authentication of remote connections. Defaults to None. None password str Password for authentication of remote connections. Defaults to None. None ssh_key_path str Path to a SSH Key for authentication of remote connections. Defaults to None. None private_key_string str A private SSH Key string used for authentication of remote connections. Defaults to None. None verify_ssl bool Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. False ssh_port int SSH port for authentication of remote connections. Defaults to 22. 22 ssh_timeout int SSH timeout for authentication of remote connections. Defaults to 5. 5 kwargs dict If provided, keys matching inputs for a test will be replaced. Default is None. required Raises: Type Description ValueError If a provided technique is unknown we raise an error. Source code in atomic_operator/atomic_operator.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def run ( self , techniques : list = [ 'all' ], test_guids : list = [], select_tests = False , atomics_path = os . getcwd (), check_prereqs = False , get_prereqs = False , cleanup = False , copy_source_files = True , command_timeout = 20 , debug = False , prompt_for_input_args = False , return_atomics = False , config_file = None , config_file_only = False , hosts = [], username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , * args , ** kwargs ) -> None : \"\"\"The main method in which we run Atomic Red Team tests. Args: techniques (list, optional): One or more defined techniques by attack_technique ID. Defaults to 'all'. test_guids (list, optional): One or more Atomic test GUIDs. Defaults to None. select_tests (bool, optional): Select one or more tests from provided techniques. Defaults to False. atomics_path (str, optional): The path of Atomic tests. Defaults to os.getcwd(). check_prereqs (bool, optional): Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. get_prereqs (bool, optional): Whether or not you want to retrieve prerequisites. Defaults to False. cleanup (bool, optional): Whether or not you want to run cleanup command(s). Defaults to False. copy_source_files (bool, optional): Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. command_timeout (int, optional): Timeout duration for each command. Defaults to 20. debug (bool, optional): Whether or not you want to output details about tests being ran. Defaults to False. prompt_for_input_args (bool, optional): Whether you want to prompt for input arguments for each test. Defaults to False. return_atomics (bool, optional): Whether or not you want to return atomics instead of running them. Defaults to False. config_file (str, optional): A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. config_file_only (bool, optional): Whether or not you want to run tests based on the provided config_file only. Defaults to False. hosts (list, optional): A list of one or more remote hosts to run a test on. Defaults to []. username (str, optional): Username for authentication of remote connections. Defaults to None. password (str, optional): Password for authentication of remote connections. Defaults to None. ssh_key_path (str, optional): Path to a SSH Key for authentication of remote connections. Defaults to None. private_key_string (str, optional): A private SSH Key string used for authentication of remote connections. Defaults to None. verify_ssl (bool, optional): Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. ssh_port (int, optional): SSH port for authentication of remote connections. Defaults to 22. ssh_timeout (int, optional): SSH timeout for authentication of remote connections. Defaults to 5. kwargs (dict, optional): If provided, keys matching inputs for a test will be replaced. Default is None. Raises: ValueError: If a provided technique is unknown we raise an error. \"\"\" response = self . __check_arguments ( kwargs , self . run ) if response : return response if kwargs . get ( 'help' ): return self . help ( method = 'run' ) if debug : import logging logging . getLogger () . setLevel ( logging . DEBUG ) count = 0 if check_prereqs : count += 1 if get_prereqs : count += 1 if cleanup : count += 1 if count > 1 : return IncorrectParameters ( f \"You have passed in incompatible arguments. Please only provide one of 'check_prereqs','get_prereqs','cleanup'.\" ) atomics_path = self . __find_path ( atomics_path ) if not atomics_path : return AtomicsFolderNotFound ( 'Unable to find a folder containing Atomics. Please provide a path or run get_atomics.' ) Base . CONFIG = Config ( atomics_path = atomics_path , check_prereqs = check_prereqs , get_prereqs = get_prereqs , cleanup = cleanup , command_timeout = command_timeout , debug = debug , prompt_for_input_args = prompt_for_input_args , kwargs = kwargs , copy_source_files = copy_source_files ) # taking inputs from both config_file and passed in values via command # line to build a run_list of objects self . __config_parser = ConfigParser ( config_file = config_file , techniques = None if config_file_only else self . parse_input_lists ( techniques ), test_guids = None if config_file_only else self . parse_input_lists ( test_guids ), host_list = None if config_file_only else self . parse_input_lists ( hosts ), username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout , select_tests = select_tests ) self . __run_list = self . __config_parser . run_list __return_atomics = [] for item in self . __run_list : if return_atomics : __return_atomics . append ( item ) elif kwargs . get ( 'kwargs' ): self . __run_technique ( item , ** kwargs . get ( 'kwargs' )) else : self . __run_technique ( item ) if return_atomics and __return_atomics : return __return_atomics return self . __test_responses Base Source code in atomic_operator/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class Base ( metaclass = LoggingBase ): CONFIG = None ATOMIC_RED_TEAM_REPO = 'https://github.com/redcanaryco/atomic-red-team/zipball/master/' command_map = { 'command_prompt' : { 'windows' : 'C: \\\\ Windows \\\\ System32 \\\\ cmd.exe' , 'linux' : '/bin/sh' , 'macos' : '/bin/sh' , 'default' : '/bin/sh' }, 'powershell' : { 'windows' : 'C: \\\\ Windows \\\\ System32 \\\\ WindowsPowerShell \\\\ v1.0 \\\\ powershell.exe' }, 'sh' : { 'linux' : '/bin/sh' , 'macos' : '/bin/sh' }, 'bash' : { 'linux' : '/bin/bash' , 'macos' : '/bin/bash' } } VARIABLE_REPLACEMENTS = { 'command_prompt' : { '%temp%' : \"$env:TEMP\" } } _replacement_strings = [ '#{{ {0} }}' , '${{ {0} }}' ] def download_atomic_red_team_repo ( self , save_path , ** kwargs ) -> str : \"\"\"Downloads the Atomic Red Team repository from github Args: save_path (str): The path to save the downloaded and extracted ZIP contents Returns: str: A string of the location the data was saved to. \"\"\" response = requests . get ( Base . ATOMIC_RED_TEAM_REPO , stream = True , ** kwargs ) z = zipfile . ZipFile ( BytesIO ( response . content )) with zipfile . ZipFile ( BytesIO ( response . content )) as zf : for member in zf . infolist (): file_path = os . path . realpath ( os . path . join ( save_path , member . filename )) if file_path . startswith ( os . path . realpath ( save_path )): zf . extract ( member , save_path ) return z . namelist ()[ 0 ] def get_local_system_platform ( self ) -> str : \"\"\"Identifies the local systems operating system platform Returns: str: The current/local systems operating system platform \"\"\" os_name = platform . system () . lower () if os_name == \"darwin\" : return \"macos\" return os_name def get_abs_path ( self , value ) -> str : \"\"\"Formats and returns the absolute path for a path value Args: value (str): A path string in many different accepted formats Returns: str: The absolute path of the provided string \"\"\" return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value ))) def prompt_user_for_input ( self , title , input_object ): \"\"\"Prompts user for input values based on the provided values. \"\"\" print ( f \"\"\" Inputs for { title } : Input Name: { input_object . name } Default: { input_object . default } Description: { input_object . description } \"\"\" ) print ( f \"Please provide a value for { input_object . name } (If blank, default is used):\" ,) value = sys . stdin . readline () if bool ( value ): return value return input_object . default def parse_input_lists ( self , value ): value_list = None if not isinstance ( value , list ): value_list = set ([ t . strip () for t in value . split ( ',' )]) else : value_list = set ( value ) return list ( value_list ) def _path_replacement ( self , string , path ): try : string = string . replace ( '$PathToAtomicsFolder' , path ) except : pass try : string = string . replace ( 'PathToAtomicsFolder' , path ) except : pass return string def _replace_command_string ( self , command : str , path : str , input_arguments : list = [], executor = None ): if command : command = self . _path_replacement ( command , path ) if input_arguments : for input in input_arguments : for string in self . _replacement_strings : try : command = command . replace ( str ( string . format ( input . name )), str ( input . value )) except : # catching errors since some inputs are actually integers but defined as strings pass if executor and self . VARIABLE_REPLACEMENTS . get ( executor ): for key , val in self . VARIABLE_REPLACEMENTS [ executor ] . items (): try : command = command . replace ( key , val ) except : pass return self . _path_replacement ( command , path ) def _check_if_aws ( self , test ): if 'iaas:aws' in test . supported_platforms and self . get_local_system_platform () in [ 'macos' , 'linux' ]: return True return False def _check_platform ( self , test , show_output = False ) -> bool : if self . _check_if_aws ( test ): return True if test . supported_platforms and self . get_local_system_platform () not in test . supported_platforms : self . __logger . info ( f \"You provided a test ( { test . auto_generated_guid } ) ' { test . name } ' which is not supported on this platform. Skipping...\" ) return False return True def _set_input_arguments ( self , test , ** kwargs ): if test . input_arguments : if kwargs : for input in test . input_arguments : for key , val in kwargs . items (): if input . name == key : input . value = val if Base . CONFIG . prompt_for_input_args : for input in test . input_arguments : input . value = self . prompt_user_for_input ( test . name , input ) for key , val in self . VARIABLE_REPLACEMENTS . items (): if test . executor . name == key : for k , v in val . items (): for input in test . input_arguments : if k in input . default : input . value = input . default . replace ( k , v ) for input in test . input_arguments : if input . value == None : input . value = input . default def select_atomic_tests ( self , technique ): options = None test_list = [] for test in technique . atomic_tests : test_list . append ( test ) if test_list : options = pick ( test_list , title = f \"Select Test(s) for Technique { technique . attack_technique } ( { technique . display_name } )\" , multiselect = True , options_map_func = self . format_pick_options ) return [ i [ 0 ] for i in options ] if options else [] def format_pick_options ( self , option ): return f \" { option . name } ( { option . auto_generated_guid } )\" download_atomic_red_team_repo ( save_path , ** kwargs ) Downloads the Atomic Red Team repository from github Parameters: Name Type Description Default save_path str The path to save the downloaded and extracted ZIP contents required Returns: Name Type Description str str A string of the location the data was saved to. Source code in atomic_operator/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def download_atomic_red_team_repo ( self , save_path , ** kwargs ) -> str : \"\"\"Downloads the Atomic Red Team repository from github Args: save_path (str): The path to save the downloaded and extracted ZIP contents Returns: str: A string of the location the data was saved to. \"\"\" response = requests . get ( Base . ATOMIC_RED_TEAM_REPO , stream = True , ** kwargs ) z = zipfile . ZipFile ( BytesIO ( response . content )) with zipfile . ZipFile ( BytesIO ( response . content )) as zf : for member in zf . infolist (): file_path = os . path . realpath ( os . path . join ( save_path , member . filename )) if file_path . startswith ( os . path . realpath ( save_path )): zf . extract ( member , save_path ) return z . namelist ()[ 0 ] get_abs_path ( value ) Formats and returns the absolute path for a path value Parameters: Name Type Description Default value str A path string in many different accepted formats required Returns: Name Type Description str str The absolute path of the provided string Source code in atomic_operator/base.py 73 74 75 76 77 78 79 80 81 82 def get_abs_path ( self , value ) -> str : \"\"\"Formats and returns the absolute path for a path value Args: value (str): A path string in many different accepted formats Returns: str: The absolute path of the provided string \"\"\" return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value ))) get_local_system_platform () Identifies the local systems operating system platform Returns: Name Type Description str str The current/local systems operating system platform Source code in atomic_operator/base.py 62 63 64 65 66 67 68 69 70 71 def get_local_system_platform ( self ) -> str : \"\"\"Identifies the local systems operating system platform Returns: str: The current/local systems operating system platform \"\"\" os_name = platform . system () . lower () if os_name == \"darwin\" : return \"macos\" return os_name prompt_user_for_input ( title , input_object ) Prompts user for input values based on the provided values. Source code in atomic_operator/base.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def prompt_user_for_input ( self , title , input_object ): \"\"\"Prompts user for input values based on the provided values. \"\"\" print ( f \"\"\" Inputs for { title } : Input Name: { input_object . name } Default: { input_object . default } Description: { input_object . description } \"\"\" ) print ( f \"Please provide a value for { input_object . name } (If blank, default is used):\" ,) value = sys . stdin . readline () if bool ( value ): return value return input_object . default ConfigParser Bases: Base Source code in atomic_operator/configparser.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class ConfigParser ( Base ): def __init__ ( self , config_file = None , techniques = None , test_guids = None , host_list = None , username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , select_tests = False ): \"\"\"Parses a provided config file as well as parameters to build a run list This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. Example: Example structure returned from provided values [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] \"\"\" self . __config_file = self . __load_config ( config_file ) self . techniques = techniques self . test_guids = test_guids self . select_tests = select_tests self . __host_list = [] if host_list : for host in self . parse_input_lists ( host_list ): self . __host_list . append ( self . __create_remote_host_object ( hostname = host , username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout )) def __load_config ( self , config_file ): if config_file and self . get_abs_path ( config_file ): config_file = self . get_abs_path ( config_file ) if not os . path . exists ( config_file ): raise FileNotFoundError ( 'Please provide a config_file path that exists' ) from .atomic.loader import Loader config = Loader () . load_technique ( config_file ) if not config . get ( 'atomic_tests' ) and not isinstance ( config , list ): raise MalformedFile ( 'Please provide one or more atomic_tests within your config_file' ) return config return {} def __parse_hosts ( self , inventory ): host_list = [] for host in inventory . get ( 'hosts' ): inputs = inventory [ 'authentication' ] host_list . append ( self . __create_remote_host_object ( hostname = host , username = inputs [ 'username' ] if inputs . get ( 'username' ) else None , password = inputs [ 'password' ] if inputs . get ( 'password' ) else None , ssh_key_path = inputs [ 'ssh_key_path' ] if inputs . get ( 'ssh_key_path' ) else None , private_key_string = inputs [ 'private_key_string' ] if inputs . get ( 'private_key_string' ) else None , verify_ssl = inputs [ 'verify_ssl' ] if inputs . get ( 'verify_ssl' ) else False , ssh_port = inputs [ 'port' ] if inputs . get ( 'port' ) else 22 , ssh_timeout = inputs [ 'timeout' ] if inputs . get ( 'timeout' ) else 5 ) ) return host_list def __create_remote_host_object ( self , hostname = None , username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 ): return Host ( hostname = hostname , username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , port = ssh_port , timeout = ssh_timeout ) def __parse_test_guids ( self , _config_file ): test_dict = {} return_list = [] if _config_file : for item in _config_file [ 'atomic_tests' ]: if item . get ( 'guid' ): if item [ 'guid' ] not in test_dict : test_dict [ item [ 'guid' ]] = [] if item . get ( 'inventories' ) and _config_file . get ( 'inventory' ): # process inventories to run commands remotely for inventory in item [ 'inventories' ]: if _config_file [ 'inventory' ] . get ( inventory ): test_dict [ item [ 'guid' ]] = self . __parse_hosts ( _config_file [ 'inventory' ][ inventory ]) if test_dict : for key , val in test_dict . items (): for item in self . __build_run_list ( test_guids = [ key ], host_list = val ): return_list . append ( item ) return return_list def __build_run_list ( self , techniques = None , test_guids = None , host_list = None , select_tests = False ): __run_list = [] self . __loaded_techniques = Loader () . load_techniques () if test_guids : for key , val in self . __loaded_techniques . items (): test_list = [] for test in val . atomic_tests : if test . auto_generated_guid in test_guids : test_list . append ( test ) if test_list : temp = self . __loaded_techniques [ key ] temp . atomic_tests = test_list temp . hosts = host_list __run_list . append ( temp ) if techniques : if 'all' not in techniques : for technique in techniques : if self . __loaded_techniques . get ( technique ): temp = self . __loaded_techniques [ technique ] if select_tests : temp . atomic_tests = self . select_atomic_tests ( self . __loaded_techniques [ technique ] ) temp . hosts = host_list __run_list . append ( temp ) elif 'all' in techniques and not test_guids : for key , val in self . __loaded_techniques . items (): temp = self . __loaded_techniques [ key ] if select_tests : temp . atomic_tests = self . select_atomic_tests ( self . __loaded_techniques [ key ] ) temp . hosts = host_list __run_list . append ( temp ) else : pass return __run_list @property def run_list ( self ): \"\"\"Returns a list of Atomic objects that will be ran. This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Returns: [list]: A list of modified Atomic objects that will be used to run either remotely or locally. \"\"\" __run_list = [] if self . __config_file : __run_list = self . __parse_test_guids ( self . __config_file ) for item in self . __build_run_list ( techniques = self . parse_input_lists ( self . techniques ) if self . techniques else [], test_guids = self . parse_input_lists ( self . test_guids ) if self . test_guids else [], host_list = self . __host_list , select_tests = self . select_tests ): __run_list . append ( item ) return __run_list @property def config ( self ): \"\"\"Returns raw converted config_file passed into class Returns: [dict]: Returns the converted config_file as dictionary. \"\"\" if self . __config_file : return self . __config_file else : return None def is_defined ( self , guid : str ): \"\"\"Checks to see if a GUID is defined within a config file Args: guid (str): The GUID defined within a parsed config file Returns: [bool]: Returns True if GUID is defined within parsed config_file \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return True return False def get_inputs ( self , guid : str ): \"\"\"Retrieves any defined inputs for a given atomic test GUID Args: guid (str): An Atomic test GUID Returns: dict: A dictionary of defined input arguments or empty \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return item . get ( 'input_arguments' , {}) return {} __init__ ( config_file = None , techniques = None , test_guids = None , host_list = None , username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , select_tests = False ) Parses a provided config file as well as parameters to build a run list This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. Example: Example structure returned from provided values [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information. Upon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Source code in atomic_operator/configparser.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , config_file = None , techniques = None , test_guids = None , host_list = None , username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , select_tests = False ): \"\"\"Parses a provided config file as well as parameters to build a run list This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. Example: Example structure returned from provided values [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] \"\"\" self . __config_file = self . __load_config ( config_file ) self . techniques = techniques self . test_guids = test_guids self . select_tests = select_tests self . __host_list = [] if host_list : for host in self . parse_input_lists ( host_list ): self . __host_list . append ( self . __create_remote_host_object ( hostname = host , username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout )) config () property Returns raw converted config_file passed into class Returns: Type Description [dict]: Returns the converted config_file as dictionary. Source code in atomic_operator/configparser.py 265 266 267 268 269 270 271 272 273 274 275 @property def config ( self ): \"\"\"Returns raw converted config_file passed into class Returns: [dict]: Returns the converted config_file as dictionary. \"\"\" if self . __config_file : return self . __config_file else : return None get_inputs ( guid ) Retrieves any defined inputs for a given atomic test GUID Parameters: Name Type Description Default guid str An Atomic test GUID required Returns: Name Type Description dict A dictionary of defined input arguments or empty Source code in atomic_operator/configparser.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def get_inputs ( self , guid : str ): \"\"\"Retrieves any defined inputs for a given atomic test GUID Args: guid (str): An Atomic test GUID Returns: dict: A dictionary of defined input arguments or empty \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return item . get ( 'input_arguments' , {}) return {} is_defined ( guid ) Checks to see if a GUID is defined within a config file Parameters: Name Type Description Default guid str The GUID defined within a parsed config file required Returns: Type Description [bool]: Returns True if GUID is defined within parsed config_file Source code in atomic_operator/configparser.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def is_defined ( self , guid : str ): \"\"\"Checks to see if a GUID is defined within a config file Args: guid (str): The GUID defined within a parsed config file Returns: [bool]: Returns True if GUID is defined within parsed config_file \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return True return False run_list () property Returns a list of Atomic objects that will be ran. This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information. Upon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Returns: [list]: A list of modified Atomic objects that will be used to run either remotely or locally. Source code in atomic_operator/configparser.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @property def run_list ( self ): \"\"\"Returns a list of Atomic objects that will be ran. This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Returns: [list]: A list of modified Atomic objects that will be used to run either remotely or locally. \"\"\" __run_list = [] if self . __config_file : __run_list = self . __parse_test_guids ( self . __config_file ) for item in self . __build_run_list ( techniques = self . parse_input_lists ( self . techniques ) if self . techniques else [], test_guids = self . parse_input_lists ( self . test_guids ) if self . test_guids else [], host_list = self . __host_list , select_tests = self . select_tests ): __run_list . append ( item ) return __run_list Config The main configuration class used across atomic-operator Raises: Type Description AtomicsFolderNotFound Raised when unable to find the provided atomics_path value Source code in atomic_operator/models.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @attr . s ( frozen = True ) class Config : \"\"\"The main configuration class used across atomic-operator Raises: AtomicsFolderNotFound: Raised when unable to find the provided atomics_path value \"\"\" atomics_path = attr . ib () check_prereqs = attr . ib ( default = False ) get_prereqs = attr . ib ( default = False ) cleanup = attr . ib ( default = False ) command_timeout = attr . ib ( default = 20 ) debug = attr . ib ( default = False ) prompt_for_input_args = attr . ib ( default = False ) kwargs = attr . ib ( default = {}) copy_source_files = attr . ib ( default = True ) def __attrs_post_init__ ( self ): object . __setattr__ ( self , 'atomics_path' , self . __get_abs_path ( self . atomics_path )) def __get_abs_path ( self , value ): return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value ))) @atomics_path . validator def validate_atomics_path ( self , attribute , value ): value = self . __get_abs_path ( value ) if not os . path . exists ( value ): raise AtomicsFolderNotFound ( 'Please provide a value for atomics_path that exists' ) Atomic A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. Source code in atomic_operator/atomic/atomic.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @attr . s class Atomic : \"\"\"A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. \"\"\" attack_technique = attr . ib () display_name = attr . ib () path = attr . ib () atomic_tests : typing . List [ AtomicTest ] = attr . ib () hosts : typing . List [ Host ] = attr . ib ( default = None ) def __attrs_post_init__ ( self ): if self . atomic_tests : test_list = [] for test in self . atomic_tests : test_list . append ( AtomicTest ( ** test )) self . atomic_tests = test_list AtomicTest A single Atomic test object structure Returns: Name Type Description AtomicTest A single Atomic test object Source code in atomic_operator/atomic/atomictest.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @attr . s class AtomicTest : \"\"\"A single Atomic test object structure Returns: AtomicTest: A single Atomic test object \"\"\" name = attr . ib () description = attr . ib () supported_platforms = attr . ib () auto_generated_guid = attr . ib () executor = attr . ib () input_arguments = attr . ib ( default = None ) dependency_executor_name = attr . ib ( default = None ) dependencies : typing . List [ AtomicDependency ] = attr . ib ( default = []) def __attrs_post_init__ ( self ): if self . input_arguments : temp_list = [] for key , val in self . input_arguments . items (): argument_dict = {} argument_dict = val argument_dict . update ({ 'name' : key , 'value' : val . get ( 'default' )}) temp_list . append ( AtomicTestInput ( ** argument_dict )) self . input_arguments = temp_list if self . executor : executor_dict = self . executor if executor_dict . get ( 'name' ) == 'manual' : if not executor_dict . get ( 'command' ): executor_dict [ 'command' ] = '' self . executor = AtomicExecutor ( ** executor_dict ) executor_dict = None else : self . executor = [] if self . dependencies : dependency_list = [] for dependency in self . dependencies : dependency_list . append ( AtomicDependency ( ** dependency )) self . dependencies = dependency_list Loader Bases: Base Source code in atomic_operator/atomic/loader.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Loader ( Base ): __techniques = {} TECHNIQUE_DIRECTORY_PATTERN = 'T*' def __get_file_name ( self , path ) -> str : return path . name . rstrip ( '.yaml' ) def find_atomics ( self , atomics_path , pattern = '**/T*/T*.yaml' ) -> list : \"\"\"Attempts to find the atomics folder within the provided atomics_path Args: atomics_path (str): A path to the atomic-red-team directory pattern (str, optional): Pattern used to find atomics and their required yaml files. Defaults to '**/T*/T*.yaml'. Returns: list: A list of paths of all identified atomics found in the given directory \"\"\" result = [] path = PurePath ( atomics_path ) for p in Path ( path ) . rglob ( pattern ): result . append ( p . resolve ()) return result def load_technique ( self , path_to_dir ) -> dict : \"\"\"Loads a provided yaml file which is typically an Atomic defintiion or configuration file. Args: path_to_dir (str): A string path to a yaml formatted file Returns: dict: Returns the loaded yaml file in a dictionary format \"\"\" try : with open ( self . get_abs_path ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } '\" ) try : # windows does not like get_abs_path so casting to string with open ( str ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except OSError as oe : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } ': { oe } \" ) def load_techniques ( self ) -> dict : \"\"\"The main entrypoint when loading techniques from disk. Raises: AtomicsFolderNotFound: Thrown when unable to find the folder containing Atomic tests Returns: dict: A dict with the key(s) as the Atomic technique ID and the val is a list of Atomic objects. \"\"\" atomics_path = Base . CONFIG . atomics_path if not os . path . exists ( self . get_abs_path ( atomics_path )): atomics_path = self . find_atomics ( self . get_abs_path ( __file__ )) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) else : atomics_path = self . find_atomics ( atomics_path ) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) for atomic_entry in atomics_path : technique = self . __get_file_name ( atomic_entry ) if not self . __techniques . get ( technique ): loaded_technique = self . load_technique ( str ( atomic_entry )) if loaded_technique : loaded_technique . update ({ 'path' : os . path . dirname ( str ( atomic_entry ))}) self . __techniques [ technique ] = Atomic ( ** loaded_technique ) return self . __techniques find_atomics ( atomics_path , pattern = '**/T*/T*.yaml' ) Attempts to find the atomics folder within the provided atomics_path Parameters: Name Type Description Default atomics_path str A path to the atomic-red-team directory required pattern str Pattern used to find atomics and their required yaml files. Defaults to ' /T /T .yaml'. '**/T*/T*.yaml' Returns: Name Type Description list list A list of paths of all identified atomics found in the given directory Source code in atomic_operator/atomic/loader.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def find_atomics ( self , atomics_path , pattern = '**/T*/T*.yaml' ) -> list : \"\"\"Attempts to find the atomics folder within the provided atomics_path Args: atomics_path (str): A path to the atomic-red-team directory pattern (str, optional): Pattern used to find atomics and their required yaml files. Defaults to '**/T*/T*.yaml'. Returns: list: A list of paths of all identified atomics found in the given directory \"\"\" result = [] path = PurePath ( atomics_path ) for p in Path ( path ) . rglob ( pattern ): result . append ( p . resolve ()) return result load_technique ( path_to_dir ) Loads a provided yaml file which is typically an Atomic defintiion or configuration file. Parameters: Name Type Description Default path_to_dir str A string path to a yaml formatted file required Returns: Name Type Description dict dict Returns the loaded yaml file in a dictionary format Source code in atomic_operator/atomic/loader.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def load_technique ( self , path_to_dir ) -> dict : \"\"\"Loads a provided yaml file which is typically an Atomic defintiion or configuration file. Args: path_to_dir (str): A string path to a yaml formatted file Returns: dict: Returns the loaded yaml file in a dictionary format \"\"\" try : with open ( self . get_abs_path ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } '\" ) try : # windows does not like get_abs_path so casting to string with open ( str ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except OSError as oe : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } ': { oe } \" ) load_techniques () The main entrypoint when loading techniques from disk. Raises: Type Description AtomicsFolderNotFound Thrown when unable to find the folder containing Atomic tests Returns: Name Type Description dict dict A dict with the key(s) as the Atomic technique ID and the val is a list of Atomic objects. Source code in atomic_operator/atomic/loader.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def load_techniques ( self ) -> dict : \"\"\"The main entrypoint when loading techniques from disk. Raises: AtomicsFolderNotFound: Thrown when unable to find the folder containing Atomic tests Returns: dict: A dict with the key(s) as the Atomic technique ID and the val is a list of Atomic objects. \"\"\" atomics_path = Base . CONFIG . atomics_path if not os . path . exists ( self . get_abs_path ( atomics_path )): atomics_path = self . find_atomics ( self . get_abs_path ( __file__ )) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) else : atomics_path = self . find_atomics ( atomics_path ) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) for atomic_entry in atomics_path : technique = self . __get_file_name ( atomic_entry ) if not self . __techniques . get ( technique ): loaded_technique = self . load_technique ( str ( atomic_entry )) if loaded_technique : loaded_technique . update ({ 'path' : os . path . dirname ( str ( atomic_entry ))}) self . __techniques [ technique ] = Atomic ( ** loaded_technique ) return self . __techniques","title":"Atomic Operator"},{"location":"atomic-operator-ref/#atomic_operator.atomic_operator.AtomicOperator","text":"Bases: Base Main class used to run Atomic Red Team tests. atomic-operator is used to run Atomic Red Team tests both locally and remotely. These tests (atomics) are predefined tests to mock or emulate a specific technique. config_file definition atomic-operator's run method can be supplied with a path to a configuration file (config_file) which defines specific tests and/or values for input parameters to facilitate automation of said tests. An example of this config_file can be seen below: inventory: linux1: executor: ssh authentication: username: root password: Somepassword! #ssk_key_path: port: 22 timeout: 5 hosts: # - 192.168.1.1 - 10.32.100.199 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2 inventories: - linux1 Raises: Type Description ValueError If a provided technique is unknown we raise an error. Source code in atomic_operator/atomic_operator.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class AtomicOperator ( Base ): \"\"\"Main class used to run Atomic Red Team tests. atomic-operator is used to run Atomic Red Team tests both locally and remotely. These tests (atomics) are predefined tests to mock or emulate a specific technique. config_file definition: atomic-operator's run method can be supplied with a path to a configuration file (config_file) which defines specific tests and/or values for input parameters to facilitate automation of said tests. An example of this config_file can be seen below: inventory: linux1: executor: ssh authentication: username: root password: Somepassword! #ssk_key_path: port: 22 timeout: 5 hosts: # - 192.168.1.1 - 10.32.100.199 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2 inventories: - linux1 Raises: ValueError: If a provided technique is unknown we raise an error. \"\"\" __test_responses = {} def __find_path ( self , value ): \"\"\"Attempts to find a path containing the atomic-red-team repository Args: value (str): A starting path to iterate through Returns: str: An absolute path containing the path to the atomic-red-team repo \"\"\" if value == os . getcwd (): for x in os . listdir ( value ): if os . path . isdir ( x ) and 'redcanaryco-atomic-red-team' in x : if os . path . exists ( self . get_abs_path ( os . path . join ( x , 'atomics' ))): return self . get_abs_path ( os . path . join ( x , 'atomics' )) else : if os . path . exists ( self . get_abs_path ( value )): return self . get_abs_path ( value ) def __check_arguments ( self , kwargs , method ): if kwargs : for arguments in inspect . getfullargspec ( method ): if isinstance ( arguments , list ): for arg in arguments : for key , val in kwargs . items (): if key in arg : return IncorrectParameters ( f \"You passed in an argument of ' { key } ' which is not recognized. Did you mean ' { arg } '?\" ) return IncorrectParameters ( f \"You passed in an argument of ' { key } ' which is not recognized.\" ) def __run_technique ( self , technique , ** kwargs ): \"\"\"This method is used to run defined Atomic tests within a MITRE ATT&CK Technique. Args: technique (Atomic): An Atomic object which contains a list of AtomicTest objects. \"\"\" self . __logger . debug ( f \"Checking technique { technique . attack_technique } ( { technique . display_name } ) for applicable tests.\" ) for test in technique . atomic_tests : self . _set_input_arguments ( test , ** kwargs ) if test . auto_generated_guid not in self . __test_responses : self . __test_responses [ test . auto_generated_guid ] = {} if technique . hosts : for host in technique . hosts : self . __logger . info ( f \"Running { test . name } test ( { test . auto_generated_guid } ) for technique { technique . attack_technique } \" ) self . __logger . debug ( f \"Description: { test . description } \" ) if test . executor . name in [ 'sh' , 'bash' ]: self . __test_responses [ test . auto_generated_guid ] . update ( RemoteRunner ( test , technique . path ) . start ( host = host , executor = 'ssh' ) ) elif test . executor . name in [ 'command_prompt' ]: self . __test_responses [ test . auto_generated_guid ] . update ( RemoteRunner ( test , technique . path ) . start ( host = host , executor = 'cmd' ) ) elif test . executor . name in [ 'powershell' ]: self . __test_responses [ test . auto_generated_guid ] . update ( RemoteRunner ( test , technique . path ) . start ( host = host , executor = 'powershell' ) ) else : self . __logger . warning ( f \"Unable to execute test since the executor is { test . executor . name } . Skipping.....\" ) else : if self . _check_platform ( test , show_output = True ): self . __logger . info ( f \"Running { test . name } test ( { test . auto_generated_guid } ) for technique { technique . attack_technique } \" ) self . __logger . debug ( f \"Description: { test . description } \" ) if self . _check_if_aws ( test ): self . __test_responses [ test . auto_generated_guid ] . update ( AWSRunner ( test , technique . path ) . start () ) else : self . __test_responses [ test . auto_generated_guid ] . update ( LocalRunner ( test , technique . path ) . start () ) if self . __test_responses . get ( test . auto_generated_guid ): self . __test_responses [ test . auto_generated_guid ] . update ({ 'technique_id' : technique . attack_technique , 'technique_name' : technique . display_name }) def help ( self , method = None ): from fire.trace import FireTrace from fire.helptext import HelpText obj = AtomicOperator if not method else getattr ( self , method ) return HelpText ( self . run , trace = FireTrace ( obj )) def get_atomics ( self , desintation = os . getcwd (), ** kwargs ): \"\"\"Downloads the RedCanary atomic-red-team repository to your local system. Args: desintation (str, optional): A folder path to download the repositorty data to. Defaults to os.getcwd(). kwargs (dict, optional): This kwargs will be passed along to Python requests library during download. Defaults to None. Returns: str: The path the data can be found at. \"\"\" if not os . path . exists ( desintation ): os . makedirs ( desintation ) desintation = kwargs . pop ( 'destination' ) if kwargs . get ( 'destination' ) else desintation folder_name = self . download_atomic_red_team_repo ( save_path = desintation , ** kwargs ) return os . path . join ( desintation , folder_name ) def run ( self , techniques : list = [ 'all' ], test_guids : list = [], select_tests = False , atomics_path = os . getcwd (), check_prereqs = False , get_prereqs = False , cleanup = False , copy_source_files = True , command_timeout = 20 , debug = False , prompt_for_input_args = False , return_atomics = False , config_file = None , config_file_only = False , hosts = [], username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , * args , ** kwargs ) -> None : \"\"\"The main method in which we run Atomic Red Team tests. Args: techniques (list, optional): One or more defined techniques by attack_technique ID. Defaults to 'all'. test_guids (list, optional): One or more Atomic test GUIDs. Defaults to None. select_tests (bool, optional): Select one or more tests from provided techniques. Defaults to False. atomics_path (str, optional): The path of Atomic tests. Defaults to os.getcwd(). check_prereqs (bool, optional): Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. get_prereqs (bool, optional): Whether or not you want to retrieve prerequisites. Defaults to False. cleanup (bool, optional): Whether or not you want to run cleanup command(s). Defaults to False. copy_source_files (bool, optional): Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. command_timeout (int, optional): Timeout duration for each command. Defaults to 20. debug (bool, optional): Whether or not you want to output details about tests being ran. Defaults to False. prompt_for_input_args (bool, optional): Whether you want to prompt for input arguments for each test. Defaults to False. return_atomics (bool, optional): Whether or not you want to return atomics instead of running them. Defaults to False. config_file (str, optional): A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. config_file_only (bool, optional): Whether or not you want to run tests based on the provided config_file only. Defaults to False. hosts (list, optional): A list of one or more remote hosts to run a test on. Defaults to []. username (str, optional): Username for authentication of remote connections. Defaults to None. password (str, optional): Password for authentication of remote connections. Defaults to None. ssh_key_path (str, optional): Path to a SSH Key for authentication of remote connections. Defaults to None. private_key_string (str, optional): A private SSH Key string used for authentication of remote connections. Defaults to None. verify_ssl (bool, optional): Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. ssh_port (int, optional): SSH port for authentication of remote connections. Defaults to 22. ssh_timeout (int, optional): SSH timeout for authentication of remote connections. Defaults to 5. kwargs (dict, optional): If provided, keys matching inputs for a test will be replaced. Default is None. Raises: ValueError: If a provided technique is unknown we raise an error. \"\"\" response = self . __check_arguments ( kwargs , self . run ) if response : return response if kwargs . get ( 'help' ): return self . help ( method = 'run' ) if debug : import logging logging . getLogger () . setLevel ( logging . DEBUG ) count = 0 if check_prereqs : count += 1 if get_prereqs : count += 1 if cleanup : count += 1 if count > 1 : return IncorrectParameters ( f \"You have passed in incompatible arguments. Please only provide one of 'check_prereqs','get_prereqs','cleanup'.\" ) atomics_path = self . __find_path ( atomics_path ) if not atomics_path : return AtomicsFolderNotFound ( 'Unable to find a folder containing Atomics. Please provide a path or run get_atomics.' ) Base . CONFIG = Config ( atomics_path = atomics_path , check_prereqs = check_prereqs , get_prereqs = get_prereqs , cleanup = cleanup , command_timeout = command_timeout , debug = debug , prompt_for_input_args = prompt_for_input_args , kwargs = kwargs , copy_source_files = copy_source_files ) # taking inputs from both config_file and passed in values via command # line to build a run_list of objects self . __config_parser = ConfigParser ( config_file = config_file , techniques = None if config_file_only else self . parse_input_lists ( techniques ), test_guids = None if config_file_only else self . parse_input_lists ( test_guids ), host_list = None if config_file_only else self . parse_input_lists ( hosts ), username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout , select_tests = select_tests ) self . __run_list = self . __config_parser . run_list __return_atomics = [] for item in self . __run_list : if return_atomics : __return_atomics . append ( item ) elif kwargs . get ( 'kwargs' ): self . __run_technique ( item , ** kwargs . get ( 'kwargs' )) else : self . __run_technique ( item ) if return_atomics and __return_atomics : return __return_atomics return self . __test_responses","title":"AtomicOperator"},{"location":"atomic-operator-ref/#atomic_operator.atomic_operator.AtomicOperator.get_atomics","text":"Downloads the RedCanary atomic-red-team repository to your local system. Parameters: Name Type Description Default desintation str A folder path to download the repositorty data to. Defaults to os.getcwd(). os.getcwd() kwargs dict This kwargs will be passed along to Python requests library during download. Defaults to None. required Returns: Name Type Description str The path the data can be found at. Source code in atomic_operator/atomic_operator.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def get_atomics ( self , desintation = os . getcwd (), ** kwargs ): \"\"\"Downloads the RedCanary atomic-red-team repository to your local system. Args: desintation (str, optional): A folder path to download the repositorty data to. Defaults to os.getcwd(). kwargs (dict, optional): This kwargs will be passed along to Python requests library during download. Defaults to None. Returns: str: The path the data can be found at. \"\"\" if not os . path . exists ( desintation ): os . makedirs ( desintation ) desintation = kwargs . pop ( 'destination' ) if kwargs . get ( 'destination' ) else desintation folder_name = self . download_atomic_red_team_repo ( save_path = desintation , ** kwargs ) return os . path . join ( desintation , folder_name )","title":"get_atomics()"},{"location":"atomic-operator-ref/#atomic_operator.atomic_operator.AtomicOperator.run","text":"The main method in which we run Atomic Red Team tests. Parameters: Name Type Description Default techniques list One or more defined techniques by attack_technique ID. Defaults to 'all'. ['all'] test_guids list One or more Atomic test GUIDs. Defaults to None. [] select_tests bool Select one or more tests from provided techniques. Defaults to False. False atomics_path str The path of Atomic tests. Defaults to os.getcwd(). os.getcwd() check_prereqs bool Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. False get_prereqs bool Whether or not you want to retrieve prerequisites. Defaults to False. False cleanup bool Whether or not you want to run cleanup command(s). Defaults to False. False copy_source_files bool Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. True command_timeout int Timeout duration for each command. Defaults to 20. 20 debug bool Whether or not you want to output details about tests being ran. Defaults to False. False prompt_for_input_args bool Whether you want to prompt for input arguments for each test. Defaults to False. False return_atomics bool Whether or not you want to return atomics instead of running them. Defaults to False. False config_file str A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. None config_file_only bool Whether or not you want to run tests based on the provided config_file only. Defaults to False. False hosts list A list of one or more remote hosts to run a test on. Defaults to []. [] username str Username for authentication of remote connections. Defaults to None. None password str Password for authentication of remote connections. Defaults to None. None ssh_key_path str Path to a SSH Key for authentication of remote connections. Defaults to None. None private_key_string str A private SSH Key string used for authentication of remote connections. Defaults to None. None verify_ssl bool Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. False ssh_port int SSH port for authentication of remote connections. Defaults to 22. 22 ssh_timeout int SSH timeout for authentication of remote connections. Defaults to 5. 5 kwargs dict If provided, keys matching inputs for a test will be replaced. Default is None. required Raises: Type Description ValueError If a provided technique is unknown we raise an error. Source code in atomic_operator/atomic_operator.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def run ( self , techniques : list = [ 'all' ], test_guids : list = [], select_tests = False , atomics_path = os . getcwd (), check_prereqs = False , get_prereqs = False , cleanup = False , copy_source_files = True , command_timeout = 20 , debug = False , prompt_for_input_args = False , return_atomics = False , config_file = None , config_file_only = False , hosts = [], username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , * args , ** kwargs ) -> None : \"\"\"The main method in which we run Atomic Red Team tests. Args: techniques (list, optional): One or more defined techniques by attack_technique ID. Defaults to 'all'. test_guids (list, optional): One or more Atomic test GUIDs. Defaults to None. select_tests (bool, optional): Select one or more tests from provided techniques. Defaults to False. atomics_path (str, optional): The path of Atomic tests. Defaults to os.getcwd(). check_prereqs (bool, optional): Whether or not to check for prereq dependencies (prereq_comand). Defaults to False. get_prereqs (bool, optional): Whether or not you want to retrieve prerequisites. Defaults to False. cleanup (bool, optional): Whether or not you want to run cleanup command(s). Defaults to False. copy_source_files (bool, optional): Whether or not you want to copy any related source (src, bin, etc.) files to a remote host. Defaults to True. command_timeout (int, optional): Timeout duration for each command. Defaults to 20. debug (bool, optional): Whether or not you want to output details about tests being ran. Defaults to False. prompt_for_input_args (bool, optional): Whether you want to prompt for input arguments for each test. Defaults to False. return_atomics (bool, optional): Whether or not you want to return atomics instead of running them. Defaults to False. config_file (str, optional): A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. config_file_only (bool, optional): Whether or not you want to run tests based on the provided config_file only. Defaults to False. hosts (list, optional): A list of one or more remote hosts to run a test on. Defaults to []. username (str, optional): Username for authentication of remote connections. Defaults to None. password (str, optional): Password for authentication of remote connections. Defaults to None. ssh_key_path (str, optional): Path to a SSH Key for authentication of remote connections. Defaults to None. private_key_string (str, optional): A private SSH Key string used for authentication of remote connections. Defaults to None. verify_ssl (bool, optional): Whether or not to verify ssl when connecting over RDP (windows). Defaults to False. ssh_port (int, optional): SSH port for authentication of remote connections. Defaults to 22. ssh_timeout (int, optional): SSH timeout for authentication of remote connections. Defaults to 5. kwargs (dict, optional): If provided, keys matching inputs for a test will be replaced. Default is None. Raises: ValueError: If a provided technique is unknown we raise an error. \"\"\" response = self . __check_arguments ( kwargs , self . run ) if response : return response if kwargs . get ( 'help' ): return self . help ( method = 'run' ) if debug : import logging logging . getLogger () . setLevel ( logging . DEBUG ) count = 0 if check_prereqs : count += 1 if get_prereqs : count += 1 if cleanup : count += 1 if count > 1 : return IncorrectParameters ( f \"You have passed in incompatible arguments. Please only provide one of 'check_prereqs','get_prereqs','cleanup'.\" ) atomics_path = self . __find_path ( atomics_path ) if not atomics_path : return AtomicsFolderNotFound ( 'Unable to find a folder containing Atomics. Please provide a path or run get_atomics.' ) Base . CONFIG = Config ( atomics_path = atomics_path , check_prereqs = check_prereqs , get_prereqs = get_prereqs , cleanup = cleanup , command_timeout = command_timeout , debug = debug , prompt_for_input_args = prompt_for_input_args , kwargs = kwargs , copy_source_files = copy_source_files ) # taking inputs from both config_file and passed in values via command # line to build a run_list of objects self . __config_parser = ConfigParser ( config_file = config_file , techniques = None if config_file_only else self . parse_input_lists ( techniques ), test_guids = None if config_file_only else self . parse_input_lists ( test_guids ), host_list = None if config_file_only else self . parse_input_lists ( hosts ), username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout , select_tests = select_tests ) self . __run_list = self . __config_parser . run_list __return_atomics = [] for item in self . __run_list : if return_atomics : __return_atomics . append ( item ) elif kwargs . get ( 'kwargs' ): self . __run_technique ( item , ** kwargs . get ( 'kwargs' )) else : self . __run_technique ( item ) if return_atomics and __return_atomics : return __return_atomics return self . __test_responses","title":"run()"},{"location":"atomic-operator-ref/#atomic_operator.base.Base","text":"Source code in atomic_operator/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class Base ( metaclass = LoggingBase ): CONFIG = None ATOMIC_RED_TEAM_REPO = 'https://github.com/redcanaryco/atomic-red-team/zipball/master/' command_map = { 'command_prompt' : { 'windows' : 'C: \\\\ Windows \\\\ System32 \\\\ cmd.exe' , 'linux' : '/bin/sh' , 'macos' : '/bin/sh' , 'default' : '/bin/sh' }, 'powershell' : { 'windows' : 'C: \\\\ Windows \\\\ System32 \\\\ WindowsPowerShell \\\\ v1.0 \\\\ powershell.exe' }, 'sh' : { 'linux' : '/bin/sh' , 'macos' : '/bin/sh' }, 'bash' : { 'linux' : '/bin/bash' , 'macos' : '/bin/bash' } } VARIABLE_REPLACEMENTS = { 'command_prompt' : { '%temp%' : \"$env:TEMP\" } } _replacement_strings = [ '#{{ {0} }}' , '${{ {0} }}' ] def download_atomic_red_team_repo ( self , save_path , ** kwargs ) -> str : \"\"\"Downloads the Atomic Red Team repository from github Args: save_path (str): The path to save the downloaded and extracted ZIP contents Returns: str: A string of the location the data was saved to. \"\"\" response = requests . get ( Base . ATOMIC_RED_TEAM_REPO , stream = True , ** kwargs ) z = zipfile . ZipFile ( BytesIO ( response . content )) with zipfile . ZipFile ( BytesIO ( response . content )) as zf : for member in zf . infolist (): file_path = os . path . realpath ( os . path . join ( save_path , member . filename )) if file_path . startswith ( os . path . realpath ( save_path )): zf . extract ( member , save_path ) return z . namelist ()[ 0 ] def get_local_system_platform ( self ) -> str : \"\"\"Identifies the local systems operating system platform Returns: str: The current/local systems operating system platform \"\"\" os_name = platform . system () . lower () if os_name == \"darwin\" : return \"macos\" return os_name def get_abs_path ( self , value ) -> str : \"\"\"Formats and returns the absolute path for a path value Args: value (str): A path string in many different accepted formats Returns: str: The absolute path of the provided string \"\"\" return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value ))) def prompt_user_for_input ( self , title , input_object ): \"\"\"Prompts user for input values based on the provided values. \"\"\" print ( f \"\"\" Inputs for { title } : Input Name: { input_object . name } Default: { input_object . default } Description: { input_object . description } \"\"\" ) print ( f \"Please provide a value for { input_object . name } (If blank, default is used):\" ,) value = sys . stdin . readline () if bool ( value ): return value return input_object . default def parse_input_lists ( self , value ): value_list = None if not isinstance ( value , list ): value_list = set ([ t . strip () for t in value . split ( ',' )]) else : value_list = set ( value ) return list ( value_list ) def _path_replacement ( self , string , path ): try : string = string . replace ( '$PathToAtomicsFolder' , path ) except : pass try : string = string . replace ( 'PathToAtomicsFolder' , path ) except : pass return string def _replace_command_string ( self , command : str , path : str , input_arguments : list = [], executor = None ): if command : command = self . _path_replacement ( command , path ) if input_arguments : for input in input_arguments : for string in self . _replacement_strings : try : command = command . replace ( str ( string . format ( input . name )), str ( input . value )) except : # catching errors since some inputs are actually integers but defined as strings pass if executor and self . VARIABLE_REPLACEMENTS . get ( executor ): for key , val in self . VARIABLE_REPLACEMENTS [ executor ] . items (): try : command = command . replace ( key , val ) except : pass return self . _path_replacement ( command , path ) def _check_if_aws ( self , test ): if 'iaas:aws' in test . supported_platforms and self . get_local_system_platform () in [ 'macos' , 'linux' ]: return True return False def _check_platform ( self , test , show_output = False ) -> bool : if self . _check_if_aws ( test ): return True if test . supported_platforms and self . get_local_system_platform () not in test . supported_platforms : self . __logger . info ( f \"You provided a test ( { test . auto_generated_guid } ) ' { test . name } ' which is not supported on this platform. Skipping...\" ) return False return True def _set_input_arguments ( self , test , ** kwargs ): if test . input_arguments : if kwargs : for input in test . input_arguments : for key , val in kwargs . items (): if input . name == key : input . value = val if Base . CONFIG . prompt_for_input_args : for input in test . input_arguments : input . value = self . prompt_user_for_input ( test . name , input ) for key , val in self . VARIABLE_REPLACEMENTS . items (): if test . executor . name == key : for k , v in val . items (): for input in test . input_arguments : if k in input . default : input . value = input . default . replace ( k , v ) for input in test . input_arguments : if input . value == None : input . value = input . default def select_atomic_tests ( self , technique ): options = None test_list = [] for test in technique . atomic_tests : test_list . append ( test ) if test_list : options = pick ( test_list , title = f \"Select Test(s) for Technique { technique . attack_technique } ( { technique . display_name } )\" , multiselect = True , options_map_func = self . format_pick_options ) return [ i [ 0 ] for i in options ] if options else [] def format_pick_options ( self , option ): return f \" { option . name } ( { option . auto_generated_guid } )\"","title":"Base"},{"location":"atomic-operator-ref/#atomic_operator.base.Base.download_atomic_red_team_repo","text":"Downloads the Atomic Red Team repository from github Parameters: Name Type Description Default save_path str The path to save the downloaded and extracted ZIP contents required Returns: Name Type Description str str A string of the location the data was saved to. Source code in atomic_operator/base.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def download_atomic_red_team_repo ( self , save_path , ** kwargs ) -> str : \"\"\"Downloads the Atomic Red Team repository from github Args: save_path (str): The path to save the downloaded and extracted ZIP contents Returns: str: A string of the location the data was saved to. \"\"\" response = requests . get ( Base . ATOMIC_RED_TEAM_REPO , stream = True , ** kwargs ) z = zipfile . ZipFile ( BytesIO ( response . content )) with zipfile . ZipFile ( BytesIO ( response . content )) as zf : for member in zf . infolist (): file_path = os . path . realpath ( os . path . join ( save_path , member . filename )) if file_path . startswith ( os . path . realpath ( save_path )): zf . extract ( member , save_path ) return z . namelist ()[ 0 ]","title":"download_atomic_red_team_repo()"},{"location":"atomic-operator-ref/#atomic_operator.base.Base.get_abs_path","text":"Formats and returns the absolute path for a path value Parameters: Name Type Description Default value str A path string in many different accepted formats required Returns: Name Type Description str str The absolute path of the provided string Source code in atomic_operator/base.py 73 74 75 76 77 78 79 80 81 82 def get_abs_path ( self , value ) -> str : \"\"\"Formats and returns the absolute path for a path value Args: value (str): A path string in many different accepted formats Returns: str: The absolute path of the provided string \"\"\" return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value )))","title":"get_abs_path()"},{"location":"atomic-operator-ref/#atomic_operator.base.Base.get_local_system_platform","text":"Identifies the local systems operating system platform Returns: Name Type Description str str The current/local systems operating system platform Source code in atomic_operator/base.py 62 63 64 65 66 67 68 69 70 71 def get_local_system_platform ( self ) -> str : \"\"\"Identifies the local systems operating system platform Returns: str: The current/local systems operating system platform \"\"\" os_name = platform . system () . lower () if os_name == \"darwin\" : return \"macos\" return os_name","title":"get_local_system_platform()"},{"location":"atomic-operator-ref/#atomic_operator.base.Base.prompt_user_for_input","text":"Prompts user for input values based on the provided values. Source code in atomic_operator/base.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def prompt_user_for_input ( self , title , input_object ): \"\"\"Prompts user for input values based on the provided values. \"\"\" print ( f \"\"\" Inputs for { title } : Input Name: { input_object . name } Default: { input_object . default } Description: { input_object . description } \"\"\" ) print ( f \"Please provide a value for { input_object . name } (If blank, default is used):\" ,) value = sys . stdin . readline () if bool ( value ): return value return input_object . default","title":"prompt_user_for_input()"},{"location":"atomic-operator-ref/#atomic_operator.configparser.ConfigParser","text":"Bases: Base Source code in atomic_operator/configparser.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class ConfigParser ( Base ): def __init__ ( self , config_file = None , techniques = None , test_guids = None , host_list = None , username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , select_tests = False ): \"\"\"Parses a provided config file as well as parameters to build a run list This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. Example: Example structure returned from provided values [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] \"\"\" self . __config_file = self . __load_config ( config_file ) self . techniques = techniques self . test_guids = test_guids self . select_tests = select_tests self . __host_list = [] if host_list : for host in self . parse_input_lists ( host_list ): self . __host_list . append ( self . __create_remote_host_object ( hostname = host , username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout )) def __load_config ( self , config_file ): if config_file and self . get_abs_path ( config_file ): config_file = self . get_abs_path ( config_file ) if not os . path . exists ( config_file ): raise FileNotFoundError ( 'Please provide a config_file path that exists' ) from .atomic.loader import Loader config = Loader () . load_technique ( config_file ) if not config . get ( 'atomic_tests' ) and not isinstance ( config , list ): raise MalformedFile ( 'Please provide one or more atomic_tests within your config_file' ) return config return {} def __parse_hosts ( self , inventory ): host_list = [] for host in inventory . get ( 'hosts' ): inputs = inventory [ 'authentication' ] host_list . append ( self . __create_remote_host_object ( hostname = host , username = inputs [ 'username' ] if inputs . get ( 'username' ) else None , password = inputs [ 'password' ] if inputs . get ( 'password' ) else None , ssh_key_path = inputs [ 'ssh_key_path' ] if inputs . get ( 'ssh_key_path' ) else None , private_key_string = inputs [ 'private_key_string' ] if inputs . get ( 'private_key_string' ) else None , verify_ssl = inputs [ 'verify_ssl' ] if inputs . get ( 'verify_ssl' ) else False , ssh_port = inputs [ 'port' ] if inputs . get ( 'port' ) else 22 , ssh_timeout = inputs [ 'timeout' ] if inputs . get ( 'timeout' ) else 5 ) ) return host_list def __create_remote_host_object ( self , hostname = None , username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 ): return Host ( hostname = hostname , username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , port = ssh_port , timeout = ssh_timeout ) def __parse_test_guids ( self , _config_file ): test_dict = {} return_list = [] if _config_file : for item in _config_file [ 'atomic_tests' ]: if item . get ( 'guid' ): if item [ 'guid' ] not in test_dict : test_dict [ item [ 'guid' ]] = [] if item . get ( 'inventories' ) and _config_file . get ( 'inventory' ): # process inventories to run commands remotely for inventory in item [ 'inventories' ]: if _config_file [ 'inventory' ] . get ( inventory ): test_dict [ item [ 'guid' ]] = self . __parse_hosts ( _config_file [ 'inventory' ][ inventory ]) if test_dict : for key , val in test_dict . items (): for item in self . __build_run_list ( test_guids = [ key ], host_list = val ): return_list . append ( item ) return return_list def __build_run_list ( self , techniques = None , test_guids = None , host_list = None , select_tests = False ): __run_list = [] self . __loaded_techniques = Loader () . load_techniques () if test_guids : for key , val in self . __loaded_techniques . items (): test_list = [] for test in val . atomic_tests : if test . auto_generated_guid in test_guids : test_list . append ( test ) if test_list : temp = self . __loaded_techniques [ key ] temp . atomic_tests = test_list temp . hosts = host_list __run_list . append ( temp ) if techniques : if 'all' not in techniques : for technique in techniques : if self . __loaded_techniques . get ( technique ): temp = self . __loaded_techniques [ technique ] if select_tests : temp . atomic_tests = self . select_atomic_tests ( self . __loaded_techniques [ technique ] ) temp . hosts = host_list __run_list . append ( temp ) elif 'all' in techniques and not test_guids : for key , val in self . __loaded_techniques . items (): temp = self . __loaded_techniques [ key ] if select_tests : temp . atomic_tests = self . select_atomic_tests ( self . __loaded_techniques [ key ] ) temp . hosts = host_list __run_list . append ( temp ) else : pass return __run_list @property def run_list ( self ): \"\"\"Returns a list of Atomic objects that will be ran. This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Returns: [list]: A list of modified Atomic objects that will be used to run either remotely or locally. \"\"\" __run_list = [] if self . __config_file : __run_list = self . __parse_test_guids ( self . __config_file ) for item in self . __build_run_list ( techniques = self . parse_input_lists ( self . techniques ) if self . techniques else [], test_guids = self . parse_input_lists ( self . test_guids ) if self . test_guids else [], host_list = self . __host_list , select_tests = self . select_tests ): __run_list . append ( item ) return __run_list @property def config ( self ): \"\"\"Returns raw converted config_file passed into class Returns: [dict]: Returns the converted config_file as dictionary. \"\"\" if self . __config_file : return self . __config_file else : return None def is_defined ( self , guid : str ): \"\"\"Checks to see if a GUID is defined within a config file Args: guid (str): The GUID defined within a parsed config file Returns: [bool]: Returns True if GUID is defined within parsed config_file \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return True return False def get_inputs ( self , guid : str ): \"\"\"Retrieves any defined inputs for a given atomic test GUID Args: guid (str): An Atomic test GUID Returns: dict: A dictionary of defined input arguments or empty \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return item . get ( 'input_arguments' , {}) return {}","title":"ConfigParser"},{"location":"atomic-operator-ref/#atomic_operator.configparser.ConfigParser.__init__","text":"Parses a provided config file as well as parameters to build a run list This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. Example: Example structure returned from provided values [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information. Upon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Source code in atomic_operator/configparser.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , config_file = None , techniques = None , test_guids = None , host_list = None , username = None , password = None , ssh_key_path = None , private_key_string = None , verify_ssl = False , ssh_port = 22 , ssh_timeout = 5 , select_tests = False ): \"\"\"Parses a provided config file as well as parameters to build a run list This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. Example: Example structure returned from provided values [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] \"\"\" self . __config_file = self . __load_config ( config_file ) self . techniques = techniques self . test_guids = test_guids self . select_tests = select_tests self . __host_list = [] if host_list : for host in self . parse_input_lists ( host_list ): self . __host_list . append ( self . __create_remote_host_object ( hostname = host , username = username , password = password , ssh_key_path = ssh_key_path , private_key_string = private_key_string , verify_ssl = verify_ssl , ssh_port = ssh_port , ssh_timeout = ssh_timeout ))","title":"__init__()"},{"location":"atomic-operator-ref/#atomic_operator.configparser.ConfigParser.config","text":"Returns raw converted config_file passed into class Returns: Type Description [dict]: Returns the converted config_file as dictionary. Source code in atomic_operator/configparser.py 265 266 267 268 269 270 271 272 273 274 275 @property def config ( self ): \"\"\"Returns raw converted config_file passed into class Returns: [dict]: Returns the converted config_file as dictionary. \"\"\" if self . __config_file : return self . __config_file else : return None","title":"config()"},{"location":"atomic-operator-ref/#atomic_operator.configparser.ConfigParser.get_inputs","text":"Retrieves any defined inputs for a given atomic test GUID Parameters: Name Type Description Default guid str An Atomic test GUID required Returns: Name Type Description dict A dictionary of defined input arguments or empty Source code in atomic_operator/configparser.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def get_inputs ( self , guid : str ): \"\"\"Retrieves any defined inputs for a given atomic test GUID Args: guid (str): An Atomic test GUID Returns: dict: A dictionary of defined input arguments or empty \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return item . get ( 'input_arguments' , {}) return {}","title":"get_inputs()"},{"location":"atomic-operator-ref/#atomic_operator.configparser.ConfigParser.is_defined","text":"Checks to see if a GUID is defined within a config file Parameters: Name Type Description Default guid str The GUID defined within a parsed config file required Returns: Type Description [bool]: Returns True if GUID is defined within parsed config_file Source code in atomic_operator/configparser.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def is_defined ( self , guid : str ): \"\"\"Checks to see if a GUID is defined within a config file Args: guid (str): The GUID defined within a parsed config file Returns: [bool]: Returns True if GUID is defined within parsed config_file \"\"\" if self . __config_file : for item in self . __config_file [ 'atomic_tests' ]: if item [ 'guid' ] == guid : return True return False","title":"is_defined()"},{"location":"atomic-operator-ref/#atomic_operator.configparser.ConfigParser.run_list","text":"Returns a list of Atomic objects that will be ran. This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information. Upon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Returns: [list]: A list of modified Atomic objects that will be used to run either remotely or locally. Source code in atomic_operator/configparser.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @property def run_list ( self ): \"\"\"Returns a list of Atomic objects that will be ran. This list combines Atomics and potentially filters tests defined within that Atomic object based on passed in parameters and config_file. Additionally, a list of Host objects are added to their defined techniques or test_guids based on config and/or passed in parameters. [ Atomic( attack_technique='T1016', display_name='System Network Configuration Discovery', path='/Users/josh.rickard/_Swimlane2/atomic-operator/redcanaryco-atomic-red-team-22dd2fb/atomics/T1016', atomic_tests=[ AtomicTest( name='System Network Configuration Discovery', description='Identify network configuration information.\\n\\nUpon successful execution, ...', supported_platforms=['macos', 'linux'], auto_generated_guid='c141bbdb-7fca-4254-9fd6-f47e79447e17', executor=AtomicExecutor( name='sh', command='if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from ....', cleanup_command=None, elevation_required=False, steps=None ), input_arguments=None, dependency_executor_name=None, dependencies=[] ) ], hosts=[ Host( hostname='192.168.1.1', username='username', password='some_passowrd!', verify_ssl=False, ssh_key_path=None, private_key_string=None, port=22, timeout=5 ) ], supporting_files=[ 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/top-128.txt', 'redcanaryco-atomic-red-team-22dd2fb/atomics/T1016/src/qakbot.bat' ] ) ] Returns: [list]: A list of modified Atomic objects that will be used to run either remotely or locally. \"\"\" __run_list = [] if self . __config_file : __run_list = self . __parse_test_guids ( self . __config_file ) for item in self . __build_run_list ( techniques = self . parse_input_lists ( self . techniques ) if self . techniques else [], test_guids = self . parse_input_lists ( self . test_guids ) if self . test_guids else [], host_list = self . __host_list , select_tests = self . select_tests ): __run_list . append ( item ) return __run_list","title":"run_list()"},{"location":"atomic-operator-ref/#atomic_operator.models.Config","text":"The main configuration class used across atomic-operator Raises: Type Description AtomicsFolderNotFound Raised when unable to find the provided atomics_path value Source code in atomic_operator/models.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @attr . s ( frozen = True ) class Config : \"\"\"The main configuration class used across atomic-operator Raises: AtomicsFolderNotFound: Raised when unable to find the provided atomics_path value \"\"\" atomics_path = attr . ib () check_prereqs = attr . ib ( default = False ) get_prereqs = attr . ib ( default = False ) cleanup = attr . ib ( default = False ) command_timeout = attr . ib ( default = 20 ) debug = attr . ib ( default = False ) prompt_for_input_args = attr . ib ( default = False ) kwargs = attr . ib ( default = {}) copy_source_files = attr . ib ( default = True ) def __attrs_post_init__ ( self ): object . __setattr__ ( self , 'atomics_path' , self . __get_abs_path ( self . atomics_path )) def __get_abs_path ( self , value ): return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value ))) @atomics_path . validator def validate_atomics_path ( self , attribute , value ): value = self . __get_abs_path ( value ) if not os . path . exists ( value ): raise AtomicsFolderNotFound ( 'Please provide a value for atomics_path that exists' )","title":"Config"},{"location":"atomic-operator-ref/#atomic_operator.atomic.atomic.Atomic","text":"A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. Source code in atomic_operator/atomic/atomic.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @attr . s class Atomic : \"\"\"A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. \"\"\" attack_technique = attr . ib () display_name = attr . ib () path = attr . ib () atomic_tests : typing . List [ AtomicTest ] = attr . ib () hosts : typing . List [ Host ] = attr . ib ( default = None ) def __attrs_post_init__ ( self ): if self . atomic_tests : test_list = [] for test in self . atomic_tests : test_list . append ( AtomicTest ( ** test )) self . atomic_tests = test_list","title":"Atomic"},{"location":"atomic-operator-ref/#atomic_operator.atomic.atomictest.AtomicTest","text":"A single Atomic test object structure Returns: Name Type Description AtomicTest A single Atomic test object Source code in atomic_operator/atomic/atomictest.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @attr . s class AtomicTest : \"\"\"A single Atomic test object structure Returns: AtomicTest: A single Atomic test object \"\"\" name = attr . ib () description = attr . ib () supported_platforms = attr . ib () auto_generated_guid = attr . ib () executor = attr . ib () input_arguments = attr . ib ( default = None ) dependency_executor_name = attr . ib ( default = None ) dependencies : typing . List [ AtomicDependency ] = attr . ib ( default = []) def __attrs_post_init__ ( self ): if self . input_arguments : temp_list = [] for key , val in self . input_arguments . items (): argument_dict = {} argument_dict = val argument_dict . update ({ 'name' : key , 'value' : val . get ( 'default' )}) temp_list . append ( AtomicTestInput ( ** argument_dict )) self . input_arguments = temp_list if self . executor : executor_dict = self . executor if executor_dict . get ( 'name' ) == 'manual' : if not executor_dict . get ( 'command' ): executor_dict [ 'command' ] = '' self . executor = AtomicExecutor ( ** executor_dict ) executor_dict = None else : self . executor = [] if self . dependencies : dependency_list = [] for dependency in self . dependencies : dependency_list . append ( AtomicDependency ( ** dependency )) self . dependencies = dependency_list","title":"AtomicTest"},{"location":"atomic-operator-ref/#atomic_operator.atomic.loader.Loader","text":"Bases: Base Source code in atomic_operator/atomic/loader.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Loader ( Base ): __techniques = {} TECHNIQUE_DIRECTORY_PATTERN = 'T*' def __get_file_name ( self , path ) -> str : return path . name . rstrip ( '.yaml' ) def find_atomics ( self , atomics_path , pattern = '**/T*/T*.yaml' ) -> list : \"\"\"Attempts to find the atomics folder within the provided atomics_path Args: atomics_path (str): A path to the atomic-red-team directory pattern (str, optional): Pattern used to find atomics and their required yaml files. Defaults to '**/T*/T*.yaml'. Returns: list: A list of paths of all identified atomics found in the given directory \"\"\" result = [] path = PurePath ( atomics_path ) for p in Path ( path ) . rglob ( pattern ): result . append ( p . resolve ()) return result def load_technique ( self , path_to_dir ) -> dict : \"\"\"Loads a provided yaml file which is typically an Atomic defintiion or configuration file. Args: path_to_dir (str): A string path to a yaml formatted file Returns: dict: Returns the loaded yaml file in a dictionary format \"\"\" try : with open ( self . get_abs_path ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } '\" ) try : # windows does not like get_abs_path so casting to string with open ( str ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except OSError as oe : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } ': { oe } \" ) def load_techniques ( self ) -> dict : \"\"\"The main entrypoint when loading techniques from disk. Raises: AtomicsFolderNotFound: Thrown when unable to find the folder containing Atomic tests Returns: dict: A dict with the key(s) as the Atomic technique ID and the val is a list of Atomic objects. \"\"\" atomics_path = Base . CONFIG . atomics_path if not os . path . exists ( self . get_abs_path ( atomics_path )): atomics_path = self . find_atomics ( self . get_abs_path ( __file__ )) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) else : atomics_path = self . find_atomics ( atomics_path ) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) for atomic_entry in atomics_path : technique = self . __get_file_name ( atomic_entry ) if not self . __techniques . get ( technique ): loaded_technique = self . load_technique ( str ( atomic_entry )) if loaded_technique : loaded_technique . update ({ 'path' : os . path . dirname ( str ( atomic_entry ))}) self . __techniques [ technique ] = Atomic ( ** loaded_technique ) return self . __techniques","title":"Loader"},{"location":"atomic-operator-ref/#atomic_operator.atomic.loader.Loader.find_atomics","text":"Attempts to find the atomics folder within the provided atomics_path Parameters: Name Type Description Default atomics_path str A path to the atomic-red-team directory required pattern str Pattern used to find atomics and their required yaml files. Defaults to ' /T /T .yaml'. '**/T*/T*.yaml' Returns: Name Type Description list list A list of paths of all identified atomics found in the given directory Source code in atomic_operator/atomic/loader.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def find_atomics ( self , atomics_path , pattern = '**/T*/T*.yaml' ) -> list : \"\"\"Attempts to find the atomics folder within the provided atomics_path Args: atomics_path (str): A path to the atomic-red-team directory pattern (str, optional): Pattern used to find atomics and their required yaml files. Defaults to '**/T*/T*.yaml'. Returns: list: A list of paths of all identified atomics found in the given directory \"\"\" result = [] path = PurePath ( atomics_path ) for p in Path ( path ) . rglob ( pattern ): result . append ( p . resolve ()) return result","title":"find_atomics()"},{"location":"atomic-operator-ref/#atomic_operator.atomic.loader.Loader.load_technique","text":"Loads a provided yaml file which is typically an Atomic defintiion or configuration file. Parameters: Name Type Description Default path_to_dir str A string path to a yaml formatted file required Returns: Name Type Description dict dict Returns the loaded yaml file in a dictionary format Source code in atomic_operator/atomic/loader.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def load_technique ( self , path_to_dir ) -> dict : \"\"\"Loads a provided yaml file which is typically an Atomic defintiion or configuration file. Args: path_to_dir (str): A string path to a yaml formatted file Returns: dict: Returns the loaded yaml file in a dictionary format \"\"\" try : with open ( self . get_abs_path ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } '\" ) try : # windows does not like get_abs_path so casting to string with open ( str ( path_to_dir ), 'r' , encoding = \"utf-8\" ) as f : return yaml . safe_load ( f . read ()) except OSError as oe : self . __logger . warning ( f \"Unable to load technique in ' { path_to_dir } ': { oe } \" )","title":"load_technique()"},{"location":"atomic-operator-ref/#atomic_operator.atomic.loader.Loader.load_techniques","text":"The main entrypoint when loading techniques from disk. Raises: Type Description AtomicsFolderNotFound Thrown when unable to find the folder containing Atomic tests Returns: Name Type Description dict dict A dict with the key(s) as the Atomic technique ID and the val is a list of Atomic objects. Source code in atomic_operator/atomic/loader.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def load_techniques ( self ) -> dict : \"\"\"The main entrypoint when loading techniques from disk. Raises: AtomicsFolderNotFound: Thrown when unable to find the folder containing Atomic tests Returns: dict: A dict with the key(s) as the Atomic technique ID and the val is a list of Atomic objects. \"\"\" atomics_path = Base . CONFIG . atomics_path if not os . path . exists ( self . get_abs_path ( atomics_path )): atomics_path = self . find_atomics ( self . get_abs_path ( __file__ )) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) else : atomics_path = self . find_atomics ( atomics_path ) if not atomics_path : raise AtomicsFolderNotFound ( 'Unable to find any atomics folder' ) for atomic_entry in atomics_path : technique = self . __get_file_name ( atomic_entry ) if not self . __techniques . get ( technique ): loaded_technique = self . load_technique ( str ( atomic_entry )) if loaded_technique : loaded_technique . update ({ 'path' : os . path . dirname ( str ( atomic_entry ))}) self . __techniques [ technique ] = Atomic ( ** loaded_technique ) return self . __techniques","title":"load_techniques()"},{"location":"atomic-operator/","text":"Atomic Operator atomic-operator can be used on the command line or via your own scripts. This page shows how the options available within atomic-operator . Command Line You can access the general help for atomic-operator by simplying typing the following in your shell. atomic-operator Retrieving Atomic Tests In order to use atomic-operator you must have one or more atomic-red-team tests (Atomics) on your local system. atomic-operator provides you with the ability to download the Atomic Red Team repository. You can do so by running the following at the command line: atomic-operator get_atomics # You can specify the destination directory by using the --destination flag atomic-operator get_atomics --destination \"/tmp/some_directory\" Running Tests In order to run a test you must provide some additional properties (and options if desired). The main method to run tests is named run . # This will run ALL tests compatiable with your local operating system atomic-operator run --atomics-path \"/tmp/some_directory/redcanaryco-atomic-red-team-3700624\" The run command has several mandatory and optional parameters that can be used. You can see these by running the help for this command: atomic-operator run --help It will return the following: NAME atomic-operator run - The main method in which we run Atomic Red Team tests. SYNOPSIS atomic-operator run <flags> DESCRIPTION config_file definition: atomic-operator's run method can be supplied with a path to a configuration file (config_file) which defines specific tests and/or values for input parameters to facilitate automation of said tests. An example of this config_file can be seen below: inventory: windows1: executor: powershell # or cmd input: username: username password: some_passowrd! verify_ssl: false hosts: - 192.168.1.1 - 10.32.1.1 # etc linux1: executor: ssh authentication: username: username password: some_passowrd! #ssk_key_path: port: 22 timeout: 5 hosts: - 192.168.1.1 - 10.32.100.1 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt inventories: - windows1 - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument inventories: - windows1 - linux1 - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2 inventories: - linux1 FLAGS --techniques=TECHNIQUES One or more defined techniques by attack_technique ID. Defaults to 'All'. --test_guids=TEST_GUIDS One or more Atomic test GUIDs. Defaults to None. --atomics_path=ATOMICS_PATH The path of Atomic tests. Defaults to os.getcwd(). --check_dependencies=CHECK_DEPENDENCIES Whether or not to check for dependencies. Defaults to False. --get_prereqs=GET_PREREQS Whether or not you want to retrieve prerequisites. Defaults to False. --cleanup=CLEANUP Whether or not you want to run cleanup command(s). Defaults to False. --command_timeout=COMMAND_TIMEOUT Timeout duration for each command. Defaults to 20. --debug=DEBUG Whether or not you want to output details about tests being ran. Defaults to False. --prompt_for_input_args=PROMPT_FOR_INPUT_ARGS Whether you want to prompt for input arguments for each test. Defaults to False. --config_file=CONFIG_FILE A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. Additional flags are accepted. If provided, keys matching inputs for a test will be replaced. Default is None. Running atomic-operator using a config_file In addition to the ability to pass in parameters with atomic-operator you can also pass in a path to a config_file that contains all the atomic tests and their potential inputs. You can find more information about the Configuration File here Package In additional to using atomic-operator on the command line you can import it into your own scripts/code and build further automation as needed. from atomic_operator import AtomicOperator operator = AtomicOperator() # This will download a local copy of the atomic-red-team repository print(operator.get_atomics('/tmp/some_directory')) # this will run tests on your local system operator.run( technique: str='All', test_guids: list=[], atomics_path=os.getcwd(), check_dependencies=False, get_prereqs=False, cleanup=False, command_timeout=20, debug=False, prompt_for_input_args=False, config_file=\"some_path.yaml\" **kwargs )","title":"Atomic Operator"},{"location":"atomic-operator/#atomic-operator","text":"atomic-operator can be used on the command line or via your own scripts. This page shows how the options available within atomic-operator .","title":"Atomic Operator"},{"location":"atomic-operator/#command-line","text":"You can access the general help for atomic-operator by simplying typing the following in your shell. atomic-operator","title":"Command Line"},{"location":"atomic-operator/#retrieving-atomic-tests","text":"In order to use atomic-operator you must have one or more atomic-red-team tests (Atomics) on your local system. atomic-operator provides you with the ability to download the Atomic Red Team repository. You can do so by running the following at the command line: atomic-operator get_atomics # You can specify the destination directory by using the --destination flag atomic-operator get_atomics --destination \"/tmp/some_directory\"","title":"Retrieving Atomic Tests"},{"location":"atomic-operator/#running-tests","text":"In order to run a test you must provide some additional properties (and options if desired). The main method to run tests is named run . # This will run ALL tests compatiable with your local operating system atomic-operator run --atomics-path \"/tmp/some_directory/redcanaryco-atomic-red-team-3700624\" The run command has several mandatory and optional parameters that can be used. You can see these by running the help for this command: atomic-operator run --help It will return the following: NAME atomic-operator run - The main method in which we run Atomic Red Team tests. SYNOPSIS atomic-operator run <flags> DESCRIPTION config_file definition: atomic-operator's run method can be supplied with a path to a configuration file (config_file) which defines specific tests and/or values for input parameters to facilitate automation of said tests. An example of this config_file can be seen below: inventory: windows1: executor: powershell # or cmd input: username: username password: some_passowrd! verify_ssl: false hosts: - 192.168.1.1 - 10.32.1.1 # etc linux1: executor: ssh authentication: username: username password: some_passowrd! #ssk_key_path: port: 22 timeout: 5 hosts: - 192.168.1.1 - 10.32.100.1 # etc. atomic_tests: - guid: f7e6ec05-c19e-4a80-a7e7-241027992fdb input_arguments: output_file: value: custom_output.txt input_file: value: custom_input.txt inventories: - windows1 - guid: 3ff64f0b-3af2-3866-339d-38d9791407c3 input_arguments: second_arg: value: SWAPPPED argument inventories: - windows1 - linux1 - guid: 32f90516-4bc9-43bd-b18d-2cbe0b7ca9b2 inventories: - linux1 FLAGS --techniques=TECHNIQUES One or more defined techniques by attack_technique ID. Defaults to 'All'. --test_guids=TEST_GUIDS One or more Atomic test GUIDs. Defaults to None. --atomics_path=ATOMICS_PATH The path of Atomic tests. Defaults to os.getcwd(). --check_dependencies=CHECK_DEPENDENCIES Whether or not to check for dependencies. Defaults to False. --get_prereqs=GET_PREREQS Whether or not you want to retrieve prerequisites. Defaults to False. --cleanup=CLEANUP Whether or not you want to run cleanup command(s). Defaults to False. --command_timeout=COMMAND_TIMEOUT Timeout duration for each command. Defaults to 20. --debug=DEBUG Whether or not you want to output details about tests being ran. Defaults to False. --prompt_for_input_args=PROMPT_FOR_INPUT_ARGS Whether you want to prompt for input arguments for each test. Defaults to False. --config_file=CONFIG_FILE A path to a conifg_file which is used to automate atomic-operator in environments. Default to None. Additional flags are accepted. If provided, keys matching inputs for a test will be replaced. Default is None.","title":"Running Tests"},{"location":"atomic-operator/#running-atomic-operator-using-a-config_file","text":"In addition to the ability to pass in parameters with atomic-operator you can also pass in a path to a config_file that contains all the atomic tests and their potential inputs. You can find more information about the Configuration File here","title":"Running atomic-operator using a config_file"},{"location":"atomic-operator/#package","text":"In additional to using atomic-operator on the command line you can import it into your own scripts/code and build further automation as needed. from atomic_operator import AtomicOperator operator = AtomicOperator() # This will download a local copy of the atomic-red-team repository print(operator.get_atomics('/tmp/some_directory')) # this will run tests on your local system operator.run( technique: str='All', test_guids: list=[], atomics_path=os.getcwd(), check_dependencies=False, get_prereqs=False, cleanup=False, command_timeout=20, debug=False, prompt_for_input_args=False, config_file=\"some_path.yaml\" **kwargs )","title":"Package"},{"location":"atomics/","text":"Atomics As part of the Atomic Red Team project by RedCanary , you must have these atomics on you local system. atomic-operator uses these defined MITRE ATT&CK Technique tests (atomics) to run tests on your local system. Get Atomics atomic-operator provides you with the ability to download the Atomic Red Team repository. You can do so by running the following at the command line: atomic-operator get_atomics # You can specify the destination directory by using the --destination flag atomic-operator get_atomics --destination \"/tmp/some_directory\" Secondarily, you can also just clone or download the Atomics to your local system. To clone this repository, you can run: git clone https://github.com/redcanaryco/atomic-red-team.git cd atomic-red-team You can also download this repository to your local system and extract the downloaded .zip. That's it! Once you have one or more atomics on your local system then we can begin to use atomic-operator to run these tests.","title":"Get Atomics"},{"location":"atomics/#atomics","text":"As part of the Atomic Red Team project by RedCanary , you must have these atomics on you local system. atomic-operator uses these defined MITRE ATT&CK Technique tests (atomics) to run tests on your local system.","title":"Atomics"},{"location":"atomics/#get-atomics","text":"atomic-operator provides you with the ability to download the Atomic Red Team repository. You can do so by running the following at the command line: atomic-operator get_atomics # You can specify the destination directory by using the --destination flag atomic-operator get_atomics --destination \"/tmp/some_directory\" Secondarily, you can also just clone or download the Atomics to your local system. To clone this repository, you can run: git clone https://github.com/redcanaryco/atomic-red-team.git cd atomic-red-team You can also download this repository to your local system and extract the downloaded .zip. That's it! Once you have one or more atomics on your local system then we can begin to use atomic-operator to run these tests.","title":"Get Atomics"},{"location":"execution-ref/","text":"Runner Bases: Base Source code in atomic_operator/execution/runner.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class Runner ( Base ): def clean_output ( self , data ): \"\"\"Decodes data and strips CLI garbage from returned outputs and errors Args: data (str): A output or error returned from subprocess Returns: str: A cleaned string which will be displayed on the console and in logs \"\"\" if data : # Remove Windows CLI garbage data = re . sub ( r \"Microsoft\\ Windows\\ \\[version .+\\]\\r?\\nCopyright.*(\\r?\\n)+[A-Z]\\:.+?\\>\" , \"\" , data . decode ( \"utf-8\" , \"ignore\" )) # formats strings with newline and return characters return re . sub ( r \"(\\r?\\n)*[A-Z]\\:.+?\\>\" , \"\" , data ) def print_process_output ( self , command , return_code , output , errors ): \"\"\"Outputs the appropriate outputs if they exists to the console and log files Args: command (str): The command which was ran by subprocess return_code (int): The return code from subprocess output (bytes): Output from subprocess which is typically in bytes errors (bytes): Errors from subprocess which is typically in bytes \"\"\" return_dict = {} if return_code == 127 : return_dict [ 'error' ] = f \" \\n\\n Command Not Found: { command } returned exit code { return_code } : \\n Errors: { self . clean_output ( errors ) } /nOutput: { output } \" self . __logger . warning ( return_dict [ 'error' ]) return return_dict if output or errors : if output : return_dict [ 'output' ] = self . clean_output ( output ) self . __logger . info ( \" \\n\\n Output: {} \" . format ( return_dict [ 'output' ])) else : return_dict [ 'error' ] = f \" \\n\\n Command: { command } returned exit code { return_code } : \\n { self . clean_output ( errors ) } \" self . __logger . warning ( return_dict [ 'error' ]) else : self . __logger . info ( \"(No output)\" ) return return_dict def _run_dependencies ( self , host = None , executor = None ): \"\"\"Checking dependencies \"\"\" return_dict = {} if self . test . dependency_executor_name : executor = self . test . dependency_executor_name for dependency in self . test . dependencies : self . __logger . debug ( f \"Dependency description: { dependency . description } \" ) if Base . CONFIG . check_prereqs and dependency . prereq_command : self . __logger . debug ( \"Running prerequisite command\" ) response = self . execute_process ( command = dependency . prereq_command , executor = executor , host = host ) for key , val in response . items (): if key not in return_dict : return_dict [ key ] = {} return_dict [ key ] . update ({ 'prereq_command' : val }) if return_dict . get ( 'error' ): return return_dict if Base . CONFIG . get_prereqs and dependency . get_prereq_command : self . __logger . debug ( f \"Retrieving prerequistes\" ) get_prereq_response = self . execute_process ( command = dependency . get_prereq_command , executor = executor , host = host ) for key , val in get_prereq_response . items (): if key not in return_dict : return_dict [ key ] = {} return_dict [ key ] . update ({ 'get_prereqs' : val }) return return_dict def execute ( self , host_name = 'localhost' , executor = None , host = None ): \"\"\"The main method which runs a single AtomicTest object on a local system. \"\"\" return_dict = {} self . __logger . debug ( f \"Using { executor } as executor.\" ) if executor : if not Base . CONFIG . check_prereqs and not Base . CONFIG . get_prereqs and not Base . CONFIG . cleanup : self . __logger . debug ( \"Running command\" ) response = self . execute_process ( command = self . test . executor . command , executor = executor , host = host , cwd = self . test_path , elevation_required = self . test . executor . elevation_required ) return_dict . update ({ 'command' : response }) elif Base . CONFIG . check_prereqs or Base . CONFIG . get_prereqs : if self . test . dependencies : return_dict . update ( self . _run_dependencies ( host = host , executor = executor )) elif Runner . CONFIG . cleanup and self . test . executor . cleanup_command : self . __logger . debug ( \"Running cleanup command\" ) cleanup_response = self . execute_process ( command = self . test . executor . cleanup_command , executor = executor , host = host , cwd = self . test_path ) return_dict . update ({ 'cleanup' : cleanup_response }) return { host_name : return_dict } @abc . abstractmethod def start ( self ): raise NotImplementedError @abc . abstractmethod def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): raise NotImplementedError clean_output ( data ) Decodes data and strips CLI garbage from returned outputs and errors Parameters: Name Type Description Default data str A output or error returned from subprocess required Returns: Name Type Description str A cleaned string which will be displayed on the console and in logs Source code in atomic_operator/execution/runner.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def clean_output ( self , data ): \"\"\"Decodes data and strips CLI garbage from returned outputs and errors Args: data (str): A output or error returned from subprocess Returns: str: A cleaned string which will be displayed on the console and in logs \"\"\" if data : # Remove Windows CLI garbage data = re . sub ( r \"Microsoft\\ Windows\\ \\[version .+\\]\\r?\\nCopyright.*(\\r?\\n)+[A-Z]\\:.+?\\>\" , \"\" , data . decode ( \"utf-8\" , \"ignore\" )) # formats strings with newline and return characters return re . sub ( r \"(\\r?\\n)*[A-Z]\\:.+?\\>\" , \"\" , data ) execute ( host_name = 'localhost' , executor = None , host = None ) The main method which runs a single AtomicTest object on a local system. Source code in atomic_operator/execution/runner.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def execute ( self , host_name = 'localhost' , executor = None , host = None ): \"\"\"The main method which runs a single AtomicTest object on a local system. \"\"\" return_dict = {} self . __logger . debug ( f \"Using { executor } as executor.\" ) if executor : if not Base . CONFIG . check_prereqs and not Base . CONFIG . get_prereqs and not Base . CONFIG . cleanup : self . __logger . debug ( \"Running command\" ) response = self . execute_process ( command = self . test . executor . command , executor = executor , host = host , cwd = self . test_path , elevation_required = self . test . executor . elevation_required ) return_dict . update ({ 'command' : response }) elif Base . CONFIG . check_prereqs or Base . CONFIG . get_prereqs : if self . test . dependencies : return_dict . update ( self . _run_dependencies ( host = host , executor = executor )) elif Runner . CONFIG . cleanup and self . test . executor . cleanup_command : self . __logger . debug ( \"Running cleanup command\" ) cleanup_response = self . execute_process ( command = self . test . executor . cleanup_command , executor = executor , host = host , cwd = self . test_path ) return_dict . update ({ 'cleanup' : cleanup_response }) return { host_name : return_dict } print_process_output ( command , return_code , output , errors ) Outputs the appropriate outputs if they exists to the console and log files Parameters: Name Type Description Default command str The command which was ran by subprocess required return_code int The return code from subprocess required output bytes Output from subprocess which is typically in bytes required errors bytes Errors from subprocess which is typically in bytes required Source code in atomic_operator/execution/runner.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def print_process_output ( self , command , return_code , output , errors ): \"\"\"Outputs the appropriate outputs if they exists to the console and log files Args: command (str): The command which was ran by subprocess return_code (int): The return code from subprocess output (bytes): Output from subprocess which is typically in bytes errors (bytes): Errors from subprocess which is typically in bytes \"\"\" return_dict = {} if return_code == 127 : return_dict [ 'error' ] = f \" \\n\\n Command Not Found: { command } returned exit code { return_code } : \\n Errors: { self . clean_output ( errors ) } /nOutput: { output } \" self . __logger . warning ( return_dict [ 'error' ]) return return_dict if output or errors : if output : return_dict [ 'output' ] = self . clean_output ( output ) self . __logger . info ( \" \\n\\n Output: {} \" . format ( return_dict [ 'output' ])) else : return_dict [ 'error' ] = f \" \\n\\n Command: { command } returned exit code { return_code } : \\n { self . clean_output ( errors ) } \" self . __logger . warning ( return_dict [ 'error' ]) else : self . __logger . info ( \"(No output)\" ) return return_dict LocalRunner Bases: Runner Runs AtomicTest objects locally Source code in atomic_operator/execution/localrunner.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class LocalRunner ( Runner ): \"\"\"Runs AtomicTest objects locally \"\"\" def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform () def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f 'cmd.exe /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {} def _get_executor_command ( self ): \"\"\"Checking if executor works with local system platform \"\"\" __executor = None self . __logger . debug ( f \"Checking if executor works on local system platform.\" ) if self . __local_system_platform in self . test . supported_platforms : if self . test . executor . name != 'manual' : __executor = self . command_map . get ( self . test . executor . name ) . get ( self . __local_system_platform ) return __executor def start ( self ): return self . execute ( executor = self . test . executor . name ) __init__ ( atomic_test , test_path ) A single AtomicTest object is provided and ran on the local system Parameters: Name Type Description Default atomic_test AtomicTest A single AtomicTest object. required test_path Atomic A path where the AtomicTest object resides required Source code in atomic_operator/execution/localrunner.py 10 11 12 13 14 15 16 17 18 19 def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform () execute_process ( command , executor = None , host = None , cwd = None , elevation_required = False ) Executes commands using subprocess Parameters: Name Type Description Default executor str An executor or shell used to execute the provided command(s) None command str The commands to run using subprocess required cwd str A string which indicates the current working directory to run the command None elevation_required bool Whether or not elevation is required False Returns: Name Type Description tuple A tuple of either outputs or errors from subprocess Source code in atomic_operator/execution/localrunner.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f 'cmd.exe /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {} RemoteRunner Bases: Runner Source code in atomic_operator/execution/remoterunner.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class RemoteRunner ( Runner ): def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Main method to execute commands using state machine Args: command (str): The command to run remotely on the desired systems executor (str): An executor that can be passed to state machine. Defaults to None. host (str): A host to run remote commands on. Defaults to None. \"\"\" self . state = CreationState () final_state = None try : finished = False while not finished : if str ( self . state ) == 'CreationState' : self . __logger . debug ( 'Running CreationState on_event' ) self . state = self . state . on_event ( executor , command ) if str ( self . state ) == 'InnvocationState' : self . __logger . debug ( 'Running InnvocationState on_event' ) self . state = self . state . invoke ( host , executor , command , input_arguments = self . test . input_arguments , elevation_required = elevation_required ) if str ( self . state ) == 'ParseResultsState' : self . __logger . debug ( 'Running ParseResultsState on_event' ) final_state = self . state . on_event () self . __logger . info ( final_state ) finished = True except NoValidConnectionsError as ec : error_string = f 'SSH Error - Unable to connect to { host . hostname } - Received { type ( ec ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ec } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationException as ea : error_string = f 'SSH Error - Unable to authenticate to host - { host . hostname } - Received { type ( ea ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ea } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except BadAuthenticationType as eb : error_string = f 'SSH Error - Unable to use provided authentication type to host - { host . hostname } - Received { type ( eb ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { eb } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except PasswordRequiredException as ep : error_string = f 'SSH Error - Must provide a password to authenticate to host - { host . hostname } - Received { type ( ep ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ep } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationError as ewa : error_string = f 'Windows Error - Unable to authenticate to host - { host . hostname } - Received { type ( ewa ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewa } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WinRMTransportError as ewt : error_string = f 'Windows Error - Error occurred during transport on host - { host . hostname } - Received { type ( ewt ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewt } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WSManFaultError as ewf : error_string = f 'Windows Error - Received WSManFault information from host - { host . hostname } - Received { type ( ewf ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewf } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except RequestException as re : error_string = f 'Request Exception - Connection Error to the configured host - { host . hostname } - Received { type ( re ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { re } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except Exception as ex : error_string = f 'Uknown Error - Received an unknown error from host - { host . hostname } - Received { type ( ex ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ex } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } return final_state def start ( self , host = None , executor = None ): \"\"\"The main method which runs a single AtomicTest object remotely on one remote host. \"\"\" return self . execute ( host_name = host . hostname , executor = executor , host = host ) __init__ ( atomic_test , test_path ) A single AtomicTest object is provided and ran on the local system Parameters: Name Type Description Default atomic_test AtomicTest A single AtomicTest object. required test_path Atomic A path where the AtomicTest object resides required Source code in atomic_operator/execution/remoterunner.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path execute_process ( command , executor = None , host = None , cwd = None , elevation_required = False ) Main method to execute commands using state machine Parameters: Name Type Description Default command str The command to run remotely on the desired systems required executor str An executor that can be passed to state machine. Defaults to None. None host str A host to run remote commands on. Defaults to None. None Source code in atomic_operator/execution/remoterunner.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Main method to execute commands using state machine Args: command (str): The command to run remotely on the desired systems executor (str): An executor that can be passed to state machine. Defaults to None. host (str): A host to run remote commands on. Defaults to None. \"\"\" self . state = CreationState () final_state = None try : finished = False while not finished : if str ( self . state ) == 'CreationState' : self . __logger . debug ( 'Running CreationState on_event' ) self . state = self . state . on_event ( executor , command ) if str ( self . state ) == 'InnvocationState' : self . __logger . debug ( 'Running InnvocationState on_event' ) self . state = self . state . invoke ( host , executor , command , input_arguments = self . test . input_arguments , elevation_required = elevation_required ) if str ( self . state ) == 'ParseResultsState' : self . __logger . debug ( 'Running ParseResultsState on_event' ) final_state = self . state . on_event () self . __logger . info ( final_state ) finished = True except NoValidConnectionsError as ec : error_string = f 'SSH Error - Unable to connect to { host . hostname } - Received { type ( ec ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ec } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationException as ea : error_string = f 'SSH Error - Unable to authenticate to host - { host . hostname } - Received { type ( ea ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ea } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except BadAuthenticationType as eb : error_string = f 'SSH Error - Unable to use provided authentication type to host - { host . hostname } - Received { type ( eb ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { eb } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except PasswordRequiredException as ep : error_string = f 'SSH Error - Must provide a password to authenticate to host - { host . hostname } - Received { type ( ep ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ep } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationError as ewa : error_string = f 'Windows Error - Unable to authenticate to host - { host . hostname } - Received { type ( ewa ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewa } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WinRMTransportError as ewt : error_string = f 'Windows Error - Error occurred during transport on host - { host . hostname } - Received { type ( ewt ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewt } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WSManFaultError as ewf : error_string = f 'Windows Error - Received WSManFault information from host - { host . hostname } - Received { type ( ewf ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewf } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except RequestException as re : error_string = f 'Request Exception - Connection Error to the configured host - { host . hostname } - Received { type ( re ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { re } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except Exception as ex : error_string = f 'Uknown Error - Received an unknown error from host - { host . hostname } - Received { type ( ex ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ex } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } return final_state start ( host = None , executor = None ) The main method which runs a single AtomicTest object remotely on one remote host. Source code in atomic_operator/execution/remoterunner.py 100 101 102 103 def start ( self , host = None , executor = None ): \"\"\"The main method which runs a single AtomicTest object remotely on one remote host. \"\"\" return self . execute ( host_name = host . hostname , executor = executor , host = host ) AWSRunner Bases: ExecutionBase Runs AtomicTest objects against AWS using the aws-cli Source code in atomic_operator/execution/awsrunner.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class AWSRunner ( ExecutionBase ): \"\"\"Runs AtomicTest objects against AWS using the aws-cli \"\"\" def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran using the aws-cli Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform () def __check_for_aws_cli ( self ): self . __logger . debug ( 'Checking to see if aws cli is installed.' ) response = self . execute_process ( command = 'aws --version' , executor = self . _get_executor_command (), cwd = os . getcwd ()) if response and response . get ( 'error' ): self . __logger . warning ( response [ 'error' ]) return response def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f ' { self . command_map . get ( executor ) . get ( self . __local_system_platform ) } /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {} def _get_executor_command ( self ): \"\"\"Checking if executor works with local system platform \"\"\" __executor = None self . __logger . debug ( f \"Checking if executor works on local system platform.\" ) if 'iaas:aws' in self . test . supported_platforms : if self . test . executor . name != 'manual' : __executor = self . command_map . get ( self . test . executor . name ) . get ( self . __local_system_platform ) return __executor def start ( self ): response = self . __check_for_aws_cli () if not response . get ( 'error' ): return self . execute ( executor = self . test . executor . name ) return response __init__ ( atomic_test , test_path ) A single AtomicTest object is provided and ran using the aws-cli Parameters: Name Type Description Default atomic_test AtomicTest A single AtomicTest object. required test_path Atomic A path where the AtomicTest object resides required Source code in atomic_operator/execution/awsrunner.py 10 11 12 13 14 15 16 17 18 19 def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran using the aws-cli Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform () execute_process ( command , executor = None , host = None , cwd = None , elevation_required = False ) Executes commands using subprocess Parameters: Name Type Description Default executor str An executor or shell used to execute the provided command(s) None command str The commands to run using subprocess required cwd str A string which indicates the current working directory to run the command None elevation_required bool Whether or not elevation is required False Returns: Name Type Description tuple A tuple of either outputs or errors from subprocess Source code in atomic_operator/execution/awsrunner.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f ' { self . command_map . get ( executor ) . get ( self . __local_system_platform ) } /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {} CreationState Bases: State The state which is used to modify commands Source code in atomic_operator/execution/statemachine.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class CreationState ( State ): \"\"\" The state which is used to modify commands \"\"\" def powershell ( self , event ): command = None if event : if ' \\n ' in event or ' \\r ' in event : if ' \\n ' in event : command = event . replace ( ' \\n ' , '; ' ) if ' \\r ' in event : if command : command = command . replace ( ' \\r ' , '; ' ) else : command = event . replace ( ' \\r ' , '; ' ) return InnvocationState () def cmd ( self ): return InnvocationState () def ssh ( self ): return InnvocationState () def on_event ( self , command_type , command ): if command_type == 'powershell' : return self . powershell ( command ) elif command_type == 'cmd' : return self . cmd () elif command_type == 'ssh' : return self . ssh () elif command_type == 'sh' : return self . ssh () elif command_type == 'bash' : return self . ssh () return self InnvocationState Bases: State , Base The state which indicates the invocation of a command Source code in atomic_operator/execution/statemachine.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 class InnvocationState ( State , Base ): \"\"\" The state which indicates the invocation of a command \"\"\" __win_client = None def __handle_windows_errors ( self , stream ): return_list = [] for item in stream . error : return_list . append ({ 'type' : 'error' , 'value' : str ( item ) }) for item in stream . debug : return_list . append ({ 'type' : 'debug' , 'value' : str ( item ) }) for item in stream . information : return_list . append ({ 'type' : 'information' , 'value' : str ( item ) }) for item in stream . verbose : return_list . append ({ 'type' : 'verbose' , 'value' : str ( item ) }) for item in stream . warning : return_list . append ({ 'type' : 'warning' , 'value' : str ( item ) }) return return_list def __create_win_client ( self , hostinfo ): self . __win_client = Client ( hostinfo . hostname , username = hostinfo . username , password = hostinfo . password , ssl = hostinfo . verify_ssl ) def __invoke_cmd ( self , command , input_arguments = None , elevation_required = False ): if not self . __win_client : self . __create_win_client ( self . hostinfo ) # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING CMD Copier ( windows_client = self . __win_client , elevation_required = elevation_required ) . copy ( input_arguments ) command = self . _replace_command_string ( command , path = 'c:/temp' , input_arguments = input_arguments , executor = 'command_prompt' ) if elevation_required : command = f 'runas /user: { self . hostinfo . username } : { self . hostinfo . password } cmd.exe; { command } ' # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING CMD stdout , stderr , rc = self . __win_client . execute_cmd ( command ) # NOTE: rc (return code of process) should equal 0 but we are not adding logic here this is handled int he ParseResultsState class if stderr : self . __logger . error ( ' {host} responded with the following message(s): {message} ' . format ( host = self . hostinfo . hostname , message = stderr )) return ParseResultsState ( command = command , return_code = rc , output = stdout , error = stderr ) def join_path_regardless_of_separators ( self , * paths ): return os . path . sep . join ( path . rstrip ( r \"\\/\" ) for path in paths ) def __invoke_powershell ( self , command , input_arguments = None , elevation_required = False ): if not self . __win_client : self . __create_win_client ( self . hostinfo ) # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING POWERSHELL Copier ( windows_client = self . __win_client , elevation_required = elevation_required ) . copy ( input_arguments = input_arguments ) command = self . _replace_command_string ( command , path = 'c:/temp' , input_arguments = input_arguments , executor = 'powershell' ) # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING POWERSHELL if elevation_required : command = f 'Start-Process PowerShell -Verb RunAs; { command } ' output , streams , had_errors = self . __win_client . execute_ps ( command ) if not output : output = self . __handle_windows_errors ( streams ) if had_errors : self . __logger . error ( ' {host} responded with the following message(s): {message} ' . format ( host = self . hostinfo . hostname , message = self . __handle_windows_errors ( streams ) )) return ParseResultsState ( command = command , return_code = had_errors , output = output , error = self . __handle_windows_errors ( streams ) ) def __invoke_ssh ( self , command , input_arguments = None , elevation_required = False ): import paramiko ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if self . hostinfo . ssh_key_path : ssh . connect ( self . hostinfo . hostname , port = self . hostinfo . port , username = self . hostinfo . username , key_filename = self . hostinfo . ssh_key_path ) elif self . hostinfo . private_key_string : ssh . connect ( self . hostinfo . hostname , port = self . hostinfo . port , username = self . hostinfo . username , pkey = self . hostinfo . private_key_string ) elif self . hostinfo . password : ssh . connect ( self . hostinfo . hostname , port = self . hostinfo . port , username = self . hostinfo . username , password = self . hostinfo . password , timeout = self . hostinfo . timeout ) else : raise AttributeError ( 'Please provide either a ssh_key_path or a password' ) out = None from .base import Base base = Base () Copier ( ssh_client = ssh , elevation_required = elevation_required ) . copy ( input_arguments = input_arguments ) command = base . _replace_command_string ( command = command , path = '/tmp' , input_arguments = input_arguments ) if elevation_required : command = f 'sudo { command } ' ssh_stdin , ssh_stdout , ssh_stderr = ssh . exec_command ( command ) return_code = ssh_stdout . channel . recv_exit_status () out = ssh_stdout . read () err = ssh_stderr . read () ssh_stdin . flush () ssh . close () return ParseResultsState ( command = command , return_code = return_code , output = out , error = err ) def invoke ( self , hostinfo , command_type , command , input_arguments = None , elevation_required = False ): self . hostinfo = hostinfo command_type = self . get_remote_executor ( command_type ) result = None if command_type == 'powershell' : result = self . __invoke_powershell ( command , input_arguments = input_arguments , elevation_required = elevation_required ) elif command_type == 'cmd' : result = self . __invoke_cmd ( command , input_arguments = input_arguments , elevation_required = elevation_required ) elif command_type == 'ssh' : result = self . __invoke_ssh ( command , input_arguments = input_arguments , elevation_required = elevation_required ) return result ParseResultsState Bases: State , Runner The state which is used to parse the results Source code in atomic_operator/execution/statemachine.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 class ParseResultsState ( State , Runner ): \"\"\" The state which is used to parse the results \"\"\" def __init__ ( self , command = None , return_code = None , output = None , error = None ): self . result = {} self . print_process_output ( command = command , return_code = return_code , output = output , errors = error ) if output : self . result . update ({ 'output' : self . __parse ( output )}) if error : self . result . update ({ 'error' : self . __parse ( error )}) def __parse ( self , results ): if isinstance ( results , bytes ): results = results . decode ( \"utf-8\" ) . strip () return results def on_event ( self ): return self . result State We define a state object which provides some utility functions for the individual states within the state machine. Source code in atomic_operator/execution/statemachine.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class State : \"\"\" We define a state object which provides some utility functions for the individual states within the state machine. \"\"\" @classmethod def get_remote_executor ( cls , executor ): if executor == 'command_prompt' : return 'cmd' elif executor == 'powershell' : return 'powershell' elif executor == 'sh' : return 'ssh' elif executor == 'bash' : return 'ssh' elif executor == 'manual' : return None else : return executor def on_event ( self , event ): \"\"\" Handle events that are delegated to this State. \"\"\" pass def __repr__ ( self ): \"\"\" Leverages the __str__ method to describe the State. \"\"\" return self . __str__ () def __str__ ( self ): \"\"\" Returns the name of the State. \"\"\" return self . __class__ . __name__ on_event ( event ) Handle events that are delegated to this State. Source code in atomic_operator/execution/statemachine.py 43 44 45 46 47 def on_event ( self , event ): \"\"\" Handle events that are delegated to this State. \"\"\" pass","title":"Executors"},{"location":"execution-ref/#atomic_operator.execution.runner.Runner","text":"Bases: Base Source code in atomic_operator/execution/runner.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class Runner ( Base ): def clean_output ( self , data ): \"\"\"Decodes data and strips CLI garbage from returned outputs and errors Args: data (str): A output or error returned from subprocess Returns: str: A cleaned string which will be displayed on the console and in logs \"\"\" if data : # Remove Windows CLI garbage data = re . sub ( r \"Microsoft\\ Windows\\ \\[version .+\\]\\r?\\nCopyright.*(\\r?\\n)+[A-Z]\\:.+?\\>\" , \"\" , data . decode ( \"utf-8\" , \"ignore\" )) # formats strings with newline and return characters return re . sub ( r \"(\\r?\\n)*[A-Z]\\:.+?\\>\" , \"\" , data ) def print_process_output ( self , command , return_code , output , errors ): \"\"\"Outputs the appropriate outputs if they exists to the console and log files Args: command (str): The command which was ran by subprocess return_code (int): The return code from subprocess output (bytes): Output from subprocess which is typically in bytes errors (bytes): Errors from subprocess which is typically in bytes \"\"\" return_dict = {} if return_code == 127 : return_dict [ 'error' ] = f \" \\n\\n Command Not Found: { command } returned exit code { return_code } : \\n Errors: { self . clean_output ( errors ) } /nOutput: { output } \" self . __logger . warning ( return_dict [ 'error' ]) return return_dict if output or errors : if output : return_dict [ 'output' ] = self . clean_output ( output ) self . __logger . info ( \" \\n\\n Output: {} \" . format ( return_dict [ 'output' ])) else : return_dict [ 'error' ] = f \" \\n\\n Command: { command } returned exit code { return_code } : \\n { self . clean_output ( errors ) } \" self . __logger . warning ( return_dict [ 'error' ]) else : self . __logger . info ( \"(No output)\" ) return return_dict def _run_dependencies ( self , host = None , executor = None ): \"\"\"Checking dependencies \"\"\" return_dict = {} if self . test . dependency_executor_name : executor = self . test . dependency_executor_name for dependency in self . test . dependencies : self . __logger . debug ( f \"Dependency description: { dependency . description } \" ) if Base . CONFIG . check_prereqs and dependency . prereq_command : self . __logger . debug ( \"Running prerequisite command\" ) response = self . execute_process ( command = dependency . prereq_command , executor = executor , host = host ) for key , val in response . items (): if key not in return_dict : return_dict [ key ] = {} return_dict [ key ] . update ({ 'prereq_command' : val }) if return_dict . get ( 'error' ): return return_dict if Base . CONFIG . get_prereqs and dependency . get_prereq_command : self . __logger . debug ( f \"Retrieving prerequistes\" ) get_prereq_response = self . execute_process ( command = dependency . get_prereq_command , executor = executor , host = host ) for key , val in get_prereq_response . items (): if key not in return_dict : return_dict [ key ] = {} return_dict [ key ] . update ({ 'get_prereqs' : val }) return return_dict def execute ( self , host_name = 'localhost' , executor = None , host = None ): \"\"\"The main method which runs a single AtomicTest object on a local system. \"\"\" return_dict = {} self . __logger . debug ( f \"Using { executor } as executor.\" ) if executor : if not Base . CONFIG . check_prereqs and not Base . CONFIG . get_prereqs and not Base . CONFIG . cleanup : self . __logger . debug ( \"Running command\" ) response = self . execute_process ( command = self . test . executor . command , executor = executor , host = host , cwd = self . test_path , elevation_required = self . test . executor . elevation_required ) return_dict . update ({ 'command' : response }) elif Base . CONFIG . check_prereqs or Base . CONFIG . get_prereqs : if self . test . dependencies : return_dict . update ( self . _run_dependencies ( host = host , executor = executor )) elif Runner . CONFIG . cleanup and self . test . executor . cleanup_command : self . __logger . debug ( \"Running cleanup command\" ) cleanup_response = self . execute_process ( command = self . test . executor . cleanup_command , executor = executor , host = host , cwd = self . test_path ) return_dict . update ({ 'cleanup' : cleanup_response }) return { host_name : return_dict } @abc . abstractmethod def start ( self ): raise NotImplementedError @abc . abstractmethod def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): raise NotImplementedError","title":"Runner"},{"location":"execution-ref/#atomic_operator.execution.runner.Runner.clean_output","text":"Decodes data and strips CLI garbage from returned outputs and errors Parameters: Name Type Description Default data str A output or error returned from subprocess required Returns: Name Type Description str A cleaned string which will be displayed on the console and in logs Source code in atomic_operator/execution/runner.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def clean_output ( self , data ): \"\"\"Decodes data and strips CLI garbage from returned outputs and errors Args: data (str): A output or error returned from subprocess Returns: str: A cleaned string which will be displayed on the console and in logs \"\"\" if data : # Remove Windows CLI garbage data = re . sub ( r \"Microsoft\\ Windows\\ \\[version .+\\]\\r?\\nCopyright.*(\\r?\\n)+[A-Z]\\:.+?\\>\" , \"\" , data . decode ( \"utf-8\" , \"ignore\" )) # formats strings with newline and return characters return re . sub ( r \"(\\r?\\n)*[A-Z]\\:.+?\\>\" , \"\" , data )","title":"clean_output()"},{"location":"execution-ref/#atomic_operator.execution.runner.Runner.execute","text":"The main method which runs a single AtomicTest object on a local system. Source code in atomic_operator/execution/runner.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def execute ( self , host_name = 'localhost' , executor = None , host = None ): \"\"\"The main method which runs a single AtomicTest object on a local system. \"\"\" return_dict = {} self . __logger . debug ( f \"Using { executor } as executor.\" ) if executor : if not Base . CONFIG . check_prereqs and not Base . CONFIG . get_prereqs and not Base . CONFIG . cleanup : self . __logger . debug ( \"Running command\" ) response = self . execute_process ( command = self . test . executor . command , executor = executor , host = host , cwd = self . test_path , elevation_required = self . test . executor . elevation_required ) return_dict . update ({ 'command' : response }) elif Base . CONFIG . check_prereqs or Base . CONFIG . get_prereqs : if self . test . dependencies : return_dict . update ( self . _run_dependencies ( host = host , executor = executor )) elif Runner . CONFIG . cleanup and self . test . executor . cleanup_command : self . __logger . debug ( \"Running cleanup command\" ) cleanup_response = self . execute_process ( command = self . test . executor . cleanup_command , executor = executor , host = host , cwd = self . test_path ) return_dict . update ({ 'cleanup' : cleanup_response }) return { host_name : return_dict }","title":"execute()"},{"location":"execution-ref/#atomic_operator.execution.runner.Runner.print_process_output","text":"Outputs the appropriate outputs if they exists to the console and log files Parameters: Name Type Description Default command str The command which was ran by subprocess required return_code int The return code from subprocess required output bytes Output from subprocess which is typically in bytes required errors bytes Errors from subprocess which is typically in bytes required Source code in atomic_operator/execution/runner.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def print_process_output ( self , command , return_code , output , errors ): \"\"\"Outputs the appropriate outputs if they exists to the console and log files Args: command (str): The command which was ran by subprocess return_code (int): The return code from subprocess output (bytes): Output from subprocess which is typically in bytes errors (bytes): Errors from subprocess which is typically in bytes \"\"\" return_dict = {} if return_code == 127 : return_dict [ 'error' ] = f \" \\n\\n Command Not Found: { command } returned exit code { return_code } : \\n Errors: { self . clean_output ( errors ) } /nOutput: { output } \" self . __logger . warning ( return_dict [ 'error' ]) return return_dict if output or errors : if output : return_dict [ 'output' ] = self . clean_output ( output ) self . __logger . info ( \" \\n\\n Output: {} \" . format ( return_dict [ 'output' ])) else : return_dict [ 'error' ] = f \" \\n\\n Command: { command } returned exit code { return_code } : \\n { self . clean_output ( errors ) } \" self . __logger . warning ( return_dict [ 'error' ]) else : self . __logger . info ( \"(No output)\" ) return return_dict","title":"print_process_output()"},{"location":"execution-ref/#atomic_operator.execution.localrunner.LocalRunner","text":"Bases: Runner Runs AtomicTest objects locally Source code in atomic_operator/execution/localrunner.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class LocalRunner ( Runner ): \"\"\"Runs AtomicTest objects locally \"\"\" def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform () def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f 'cmd.exe /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {} def _get_executor_command ( self ): \"\"\"Checking if executor works with local system platform \"\"\" __executor = None self . __logger . debug ( f \"Checking if executor works on local system platform.\" ) if self . __local_system_platform in self . test . supported_platforms : if self . test . executor . name != 'manual' : __executor = self . command_map . get ( self . test . executor . name ) . get ( self . __local_system_platform ) return __executor def start ( self ): return self . execute ( executor = self . test . executor . name )","title":"LocalRunner"},{"location":"execution-ref/#atomic_operator.execution.localrunner.LocalRunner.__init__","text":"A single AtomicTest object is provided and ran on the local system Parameters: Name Type Description Default atomic_test AtomicTest A single AtomicTest object. required test_path Atomic A path where the AtomicTest object resides required Source code in atomic_operator/execution/localrunner.py 10 11 12 13 14 15 16 17 18 19 def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform ()","title":"__init__()"},{"location":"execution-ref/#atomic_operator.execution.localrunner.LocalRunner.execute_process","text":"Executes commands using subprocess Parameters: Name Type Description Default executor str An executor or shell used to execute the provided command(s) None command str The commands to run using subprocess required cwd str A string which indicates the current working directory to run the command None elevation_required bool Whether or not elevation is required False Returns: Name Type Description tuple A tuple of either outputs or errors from subprocess Source code in atomic_operator/execution/localrunner.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f 'cmd.exe /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {}","title":"execute_process()"},{"location":"execution-ref/#atomic_operator.execution.remoterunner.RemoteRunner","text":"Bases: Runner Source code in atomic_operator/execution/remoterunner.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class RemoteRunner ( Runner ): def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Main method to execute commands using state machine Args: command (str): The command to run remotely on the desired systems executor (str): An executor that can be passed to state machine. Defaults to None. host (str): A host to run remote commands on. Defaults to None. \"\"\" self . state = CreationState () final_state = None try : finished = False while not finished : if str ( self . state ) == 'CreationState' : self . __logger . debug ( 'Running CreationState on_event' ) self . state = self . state . on_event ( executor , command ) if str ( self . state ) == 'InnvocationState' : self . __logger . debug ( 'Running InnvocationState on_event' ) self . state = self . state . invoke ( host , executor , command , input_arguments = self . test . input_arguments , elevation_required = elevation_required ) if str ( self . state ) == 'ParseResultsState' : self . __logger . debug ( 'Running ParseResultsState on_event' ) final_state = self . state . on_event () self . __logger . info ( final_state ) finished = True except NoValidConnectionsError as ec : error_string = f 'SSH Error - Unable to connect to { host . hostname } - Received { type ( ec ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ec } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationException as ea : error_string = f 'SSH Error - Unable to authenticate to host - { host . hostname } - Received { type ( ea ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ea } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except BadAuthenticationType as eb : error_string = f 'SSH Error - Unable to use provided authentication type to host - { host . hostname } - Received { type ( eb ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { eb } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except PasswordRequiredException as ep : error_string = f 'SSH Error - Must provide a password to authenticate to host - { host . hostname } - Received { type ( ep ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ep } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationError as ewa : error_string = f 'Windows Error - Unable to authenticate to host - { host . hostname } - Received { type ( ewa ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewa } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WinRMTransportError as ewt : error_string = f 'Windows Error - Error occurred during transport on host - { host . hostname } - Received { type ( ewt ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewt } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WSManFaultError as ewf : error_string = f 'Windows Error - Received WSManFault information from host - { host . hostname } - Received { type ( ewf ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewf } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except RequestException as re : error_string = f 'Request Exception - Connection Error to the configured host - { host . hostname } - Received { type ( re ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { re } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except Exception as ex : error_string = f 'Uknown Error - Received an unknown error from host - { host . hostname } - Received { type ( ex ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ex } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } return final_state def start ( self , host = None , executor = None ): \"\"\"The main method which runs a single AtomicTest object remotely on one remote host. \"\"\" return self . execute ( host_name = host . hostname , executor = executor , host = host )","title":"RemoteRunner"},{"location":"execution-ref/#atomic_operator.execution.remoterunner.RemoteRunner.__init__","text":"A single AtomicTest object is provided and ran on the local system Parameters: Name Type Description Default atomic_test AtomicTest A single AtomicTest object. required test_path Atomic A path where the AtomicTest object resides required Source code in atomic_operator/execution/remoterunner.py 19 20 21 22 23 24 25 26 27 def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran on the local system Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path","title":"__init__()"},{"location":"execution-ref/#atomic_operator.execution.remoterunner.RemoteRunner.execute_process","text":"Main method to execute commands using state machine Parameters: Name Type Description Default command str The command to run remotely on the desired systems required executor str An executor that can be passed to state machine. Defaults to None. None host str A host to run remote commands on. Defaults to None. None Source code in atomic_operator/execution/remoterunner.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Main method to execute commands using state machine Args: command (str): The command to run remotely on the desired systems executor (str): An executor that can be passed to state machine. Defaults to None. host (str): A host to run remote commands on. Defaults to None. \"\"\" self . state = CreationState () final_state = None try : finished = False while not finished : if str ( self . state ) == 'CreationState' : self . __logger . debug ( 'Running CreationState on_event' ) self . state = self . state . on_event ( executor , command ) if str ( self . state ) == 'InnvocationState' : self . __logger . debug ( 'Running InnvocationState on_event' ) self . state = self . state . invoke ( host , executor , command , input_arguments = self . test . input_arguments , elevation_required = elevation_required ) if str ( self . state ) == 'ParseResultsState' : self . __logger . debug ( 'Running ParseResultsState on_event' ) final_state = self . state . on_event () self . __logger . info ( final_state ) finished = True except NoValidConnectionsError as ec : error_string = f 'SSH Error - Unable to connect to { host . hostname } - Received { type ( ec ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ec } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationException as ea : error_string = f 'SSH Error - Unable to authenticate to host - { host . hostname } - Received { type ( ea ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ea } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except BadAuthenticationType as eb : error_string = f 'SSH Error - Unable to use provided authentication type to host - { host . hostname } - Received { type ( eb ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { eb } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except PasswordRequiredException as ep : error_string = f 'SSH Error - Must provide a password to authenticate to host - { host . hostname } - Received { type ( ep ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ep } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except AuthenticationError as ewa : error_string = f 'Windows Error - Unable to authenticate to host - { host . hostname } - Received { type ( ewa ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewa } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WinRMTransportError as ewt : error_string = f 'Windows Error - Error occurred during transport on host - { host . hostname } - Received { type ( ewt ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewt } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except WSManFaultError as ewf : error_string = f 'Windows Error - Received WSManFault information from host - { host . hostname } - Received { type ( ewf ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ewf } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except RequestException as re : error_string = f 'Request Exception - Connection Error to the configured host - { host . hostname } - Received { type ( re ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { re } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } except Exception as ex : error_string = f 'Uknown Error - Received an unknown error from host - { host . hostname } - Received { type ( ex ) . __name__ } ' self . __logger . debug ( f 'Full stack trace: { ex } ' ) self . __logger . warning ( error_string ) return { 'error' : error_string } return final_state","title":"execute_process()"},{"location":"execution-ref/#atomic_operator.execution.remoterunner.RemoteRunner.start","text":"The main method which runs a single AtomicTest object remotely on one remote host. Source code in atomic_operator/execution/remoterunner.py 100 101 102 103 def start ( self , host = None , executor = None ): \"\"\"The main method which runs a single AtomicTest object remotely on one remote host. \"\"\" return self . execute ( host_name = host . hostname , executor = executor , host = host )","title":"start()"},{"location":"execution-ref/#atomic_operator.execution.awsrunner.AWSRunner","text":"Bases: ExecutionBase Runs AtomicTest objects against AWS using the aws-cli Source code in atomic_operator/execution/awsrunner.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class AWSRunner ( ExecutionBase ): \"\"\"Runs AtomicTest objects against AWS using the aws-cli \"\"\" def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran using the aws-cli Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform () def __check_for_aws_cli ( self ): self . __logger . debug ( 'Checking to see if aws cli is installed.' ) response = self . execute_process ( command = 'aws --version' , executor = self . _get_executor_command (), cwd = os . getcwd ()) if response and response . get ( 'error' ): self . __logger . warning ( response [ 'error' ]) return response def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f ' { self . command_map . get ( executor ) . get ( self . __local_system_platform ) } /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {} def _get_executor_command ( self ): \"\"\"Checking if executor works with local system platform \"\"\" __executor = None self . __logger . debug ( f \"Checking if executor works on local system platform.\" ) if 'iaas:aws' in self . test . supported_platforms : if self . test . executor . name != 'manual' : __executor = self . command_map . get ( self . test . executor . name ) . get ( self . __local_system_platform ) return __executor def start ( self ): response = self . __check_for_aws_cli () if not response . get ( 'error' ): return self . execute ( executor = self . test . executor . name ) return response","title":"AWSRunner"},{"location":"execution-ref/#atomic_operator.execution.awsrunner.AWSRunner.__init__","text":"A single AtomicTest object is provided and ran using the aws-cli Parameters: Name Type Description Default atomic_test AtomicTest A single AtomicTest object. required test_path Atomic A path where the AtomicTest object resides required Source code in atomic_operator/execution/awsrunner.py 10 11 12 13 14 15 16 17 18 19 def __init__ ( self , atomic_test , test_path ): \"\"\"A single AtomicTest object is provided and ran using the aws-cli Args: atomic_test (AtomicTest): A single AtomicTest object. test_path (Atomic): A path where the AtomicTest object resides \"\"\" self . test = atomic_test self . test_path = test_path self . __local_system_platform = self . get_local_system_platform ()","title":"__init__()"},{"location":"execution-ref/#atomic_operator.execution.awsrunner.AWSRunner.execute_process","text":"Executes commands using subprocess Parameters: Name Type Description Default executor str An executor or shell used to execute the provided command(s) None command str The commands to run using subprocess required cwd str A string which indicates the current working directory to run the command None elevation_required bool Whether or not elevation is required False Returns: Name Type Description tuple A tuple of either outputs or errors from subprocess Source code in atomic_operator/execution/awsrunner.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def execute_process ( self , command , executor = None , host = None , cwd = None , elevation_required = False ): \"\"\"Executes commands using subprocess Args: executor (str): An executor or shell used to execute the provided command(s) command (str): The commands to run using subprocess cwd (str): A string which indicates the current working directory to run the command elevation_required (bool): Whether or not elevation is required Returns: tuple: A tuple of either outputs or errors from subprocess \"\"\" if elevation_required : if executor in [ 'powershell' ]: command = f \"Start-Process PowerShell -Verb RunAs; { command } \" elif executor in [ 'cmd' , 'command_prompt' ]: command = f ' { self . command_map . get ( executor ) . get ( self . __local_system_platform ) } /c \" { command } \"' elif executor in [ 'sh' , 'bash' , 'ssh' ]: command = f \"sudo { command } \" else : self . __logger . warning ( f \"Elevation is required but the executor ' { executor } ' is unknown!\" ) command = self . _replace_command_string ( command , self . CONFIG . atomics_path , input_arguments = self . test . input_arguments , executor = executor ) executor = self . command_map . get ( executor ) . get ( self . __local_system_platform ) p = subprocess . Popen ( executor , shell = False , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , env = os . environ , cwd = cwd ) try : outs , errs = p . communicate ( bytes ( command , \"utf-8\" ) + b \" \\n \" , timeout = Runner . CONFIG . command_timeout ) response = self . print_process_output ( command , p . returncode , outs , errs ) return response except subprocess . TimeoutExpired as e : # Display output if it exists. if e . output : self . __logger . warning ( e . output ) if e . stdout : self . __logger . warning ( e . stdout ) if e . stderr : self . __logger . warning ( e . stderr ) self . __logger . warning ( \"Command timed out!\" ) # Kill the process. p . kill () return {}","title":"execute_process()"},{"location":"execution-ref/#atomic_operator.execution.statemachine.CreationState","text":"Bases: State The state which is used to modify commands Source code in atomic_operator/execution/statemachine.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class CreationState ( State ): \"\"\" The state which is used to modify commands \"\"\" def powershell ( self , event ): command = None if event : if ' \\n ' in event or ' \\r ' in event : if ' \\n ' in event : command = event . replace ( ' \\n ' , '; ' ) if ' \\r ' in event : if command : command = command . replace ( ' \\r ' , '; ' ) else : command = event . replace ( ' \\r ' , '; ' ) return InnvocationState () def cmd ( self ): return InnvocationState () def ssh ( self ): return InnvocationState () def on_event ( self , command_type , command ): if command_type == 'powershell' : return self . powershell ( command ) elif command_type == 'cmd' : return self . cmd () elif command_type == 'ssh' : return self . ssh () elif command_type == 'sh' : return self . ssh () elif command_type == 'bash' : return self . ssh () return self","title":"CreationState"},{"location":"execution-ref/#atomic_operator.execution.statemachine.InnvocationState","text":"Bases: State , Base The state which indicates the invocation of a command Source code in atomic_operator/execution/statemachine.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 class InnvocationState ( State , Base ): \"\"\" The state which indicates the invocation of a command \"\"\" __win_client = None def __handle_windows_errors ( self , stream ): return_list = [] for item in stream . error : return_list . append ({ 'type' : 'error' , 'value' : str ( item ) }) for item in stream . debug : return_list . append ({ 'type' : 'debug' , 'value' : str ( item ) }) for item in stream . information : return_list . append ({ 'type' : 'information' , 'value' : str ( item ) }) for item in stream . verbose : return_list . append ({ 'type' : 'verbose' , 'value' : str ( item ) }) for item in stream . warning : return_list . append ({ 'type' : 'warning' , 'value' : str ( item ) }) return return_list def __create_win_client ( self , hostinfo ): self . __win_client = Client ( hostinfo . hostname , username = hostinfo . username , password = hostinfo . password , ssl = hostinfo . verify_ssl ) def __invoke_cmd ( self , command , input_arguments = None , elevation_required = False ): if not self . __win_client : self . __create_win_client ( self . hostinfo ) # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING CMD Copier ( windows_client = self . __win_client , elevation_required = elevation_required ) . copy ( input_arguments ) command = self . _replace_command_string ( command , path = 'c:/temp' , input_arguments = input_arguments , executor = 'command_prompt' ) if elevation_required : command = f 'runas /user: { self . hostinfo . username } : { self . hostinfo . password } cmd.exe; { command } ' # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING CMD stdout , stderr , rc = self . __win_client . execute_cmd ( command ) # NOTE: rc (return code of process) should equal 0 but we are not adding logic here this is handled int he ParseResultsState class if stderr : self . __logger . error ( ' {host} responded with the following message(s): {message} ' . format ( host = self . hostinfo . hostname , message = stderr )) return ParseResultsState ( command = command , return_code = rc , output = stdout , error = stderr ) def join_path_regardless_of_separators ( self , * paths ): return os . path . sep . join ( path . rstrip ( r \"\\/\" ) for path in paths ) def __invoke_powershell ( self , command , input_arguments = None , elevation_required = False ): if not self . __win_client : self . __create_win_client ( self . hostinfo ) # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING POWERSHELL Copier ( windows_client = self . __win_client , elevation_required = elevation_required ) . copy ( input_arguments = input_arguments ) command = self . _replace_command_string ( command , path = 'c:/temp' , input_arguments = input_arguments , executor = 'powershell' ) # TODO: NEED TO ADD LOGIC TO TRANSFER FILES TO WINDOWS SYSTEMS USING POWERSHELL if elevation_required : command = f 'Start-Process PowerShell -Verb RunAs; { command } ' output , streams , had_errors = self . __win_client . execute_ps ( command ) if not output : output = self . __handle_windows_errors ( streams ) if had_errors : self . __logger . error ( ' {host} responded with the following message(s): {message} ' . format ( host = self . hostinfo . hostname , message = self . __handle_windows_errors ( streams ) )) return ParseResultsState ( command = command , return_code = had_errors , output = output , error = self . __handle_windows_errors ( streams ) ) def __invoke_ssh ( self , command , input_arguments = None , elevation_required = False ): import paramiko ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if self . hostinfo . ssh_key_path : ssh . connect ( self . hostinfo . hostname , port = self . hostinfo . port , username = self . hostinfo . username , key_filename = self . hostinfo . ssh_key_path ) elif self . hostinfo . private_key_string : ssh . connect ( self . hostinfo . hostname , port = self . hostinfo . port , username = self . hostinfo . username , pkey = self . hostinfo . private_key_string ) elif self . hostinfo . password : ssh . connect ( self . hostinfo . hostname , port = self . hostinfo . port , username = self . hostinfo . username , password = self . hostinfo . password , timeout = self . hostinfo . timeout ) else : raise AttributeError ( 'Please provide either a ssh_key_path or a password' ) out = None from .base import Base base = Base () Copier ( ssh_client = ssh , elevation_required = elevation_required ) . copy ( input_arguments = input_arguments ) command = base . _replace_command_string ( command = command , path = '/tmp' , input_arguments = input_arguments ) if elevation_required : command = f 'sudo { command } ' ssh_stdin , ssh_stdout , ssh_stderr = ssh . exec_command ( command ) return_code = ssh_stdout . channel . recv_exit_status () out = ssh_stdout . read () err = ssh_stderr . read () ssh_stdin . flush () ssh . close () return ParseResultsState ( command = command , return_code = return_code , output = out , error = err ) def invoke ( self , hostinfo , command_type , command , input_arguments = None , elevation_required = False ): self . hostinfo = hostinfo command_type = self . get_remote_executor ( command_type ) result = None if command_type == 'powershell' : result = self . __invoke_powershell ( command , input_arguments = input_arguments , elevation_required = elevation_required ) elif command_type == 'cmd' : result = self . __invoke_cmd ( command , input_arguments = input_arguments , elevation_required = elevation_required ) elif command_type == 'ssh' : result = self . __invoke_ssh ( command , input_arguments = input_arguments , elevation_required = elevation_required ) return result","title":"InnvocationState"},{"location":"execution-ref/#atomic_operator.execution.statemachine.ParseResultsState","text":"Bases: State , Runner The state which is used to parse the results Source code in atomic_operator/execution/statemachine.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 class ParseResultsState ( State , Runner ): \"\"\" The state which is used to parse the results \"\"\" def __init__ ( self , command = None , return_code = None , output = None , error = None ): self . result = {} self . print_process_output ( command = command , return_code = return_code , output = output , errors = error ) if output : self . result . update ({ 'output' : self . __parse ( output )}) if error : self . result . update ({ 'error' : self . __parse ( error )}) def __parse ( self , results ): if isinstance ( results , bytes ): results = results . decode ( \"utf-8\" ) . strip () return results def on_event ( self ): return self . result","title":"ParseResultsState"},{"location":"execution-ref/#atomic_operator.execution.statemachine.State","text":"We define a state object which provides some utility functions for the individual states within the state machine. Source code in atomic_operator/execution/statemachine.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class State : \"\"\" We define a state object which provides some utility functions for the individual states within the state machine. \"\"\" @classmethod def get_remote_executor ( cls , executor ): if executor == 'command_prompt' : return 'cmd' elif executor == 'powershell' : return 'powershell' elif executor == 'sh' : return 'ssh' elif executor == 'bash' : return 'ssh' elif executor == 'manual' : return None else : return executor def on_event ( self , event ): \"\"\" Handle events that are delegated to this State. \"\"\" pass def __repr__ ( self ): \"\"\" Leverages the __str__ method to describe the State. \"\"\" return self . __str__ () def __str__ ( self ): \"\"\" Returns the name of the State. \"\"\" return self . __class__ . __name__","title":"State"},{"location":"execution-ref/#atomic_operator.execution.statemachine.State.on_event","text":"Handle events that are delegated to this State. Source code in atomic_operator/execution/statemachine.py 43 44 45 46 47 def on_event ( self , event ): \"\"\" Handle events that are delegated to this State. \"\"\" pass","title":"on_event()"},{"location":"models-ref/","text":"Config The main configuration class used across atomic-operator Raises: Type Description AtomicsFolderNotFound Raised when unable to find the provided atomics_path value Source code in atomic_operator/models.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @attr . s ( frozen = True ) class Config : \"\"\"The main configuration class used across atomic-operator Raises: AtomicsFolderNotFound: Raised when unable to find the provided atomics_path value \"\"\" atomics_path = attr . ib () check_prereqs = attr . ib ( default = False ) get_prereqs = attr . ib ( default = False ) cleanup = attr . ib ( default = False ) command_timeout = attr . ib ( default = 20 ) debug = attr . ib ( default = False ) prompt_for_input_args = attr . ib ( default = False ) kwargs = attr . ib ( default = {}) copy_source_files = attr . ib ( default = True ) def __attrs_post_init__ ( self ): object . __setattr__ ( self , 'atomics_path' , self . __get_abs_path ( self . atomics_path )) def __get_abs_path ( self , value ): return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value ))) @atomics_path . validator def validate_atomics_path ( self , attribute , value ): value = self . __get_abs_path ( value ) if not os . path . exists ( value ): raise AtomicsFolderNotFound ( 'Please provide a value for atomics_path that exists' ) Atomic A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. Source code in atomic_operator/atomic/atomic.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @attr . s class Atomic : \"\"\"A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. \"\"\" attack_technique = attr . ib () display_name = attr . ib () path = attr . ib () atomic_tests : typing . List [ AtomicTest ] = attr . ib () hosts : typing . List [ Host ] = attr . ib ( default = None ) def __attrs_post_init__ ( self ): if self . atomic_tests : test_list = [] for test in self . atomic_tests : test_list . append ( AtomicTest ( ** test )) self . atomic_tests = test_list AtomicTest A single Atomic test object structure Returns: Name Type Description AtomicTest A single Atomic test object Source code in atomic_operator/atomic/atomictest.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @attr . s class AtomicTest : \"\"\"A single Atomic test object structure Returns: AtomicTest: A single Atomic test object \"\"\" name = attr . ib () description = attr . ib () supported_platforms = attr . ib () auto_generated_guid = attr . ib () executor = attr . ib () input_arguments = attr . ib ( default = None ) dependency_executor_name = attr . ib ( default = None ) dependencies : typing . List [ AtomicDependency ] = attr . ib ( default = []) def __attrs_post_init__ ( self ): if self . input_arguments : temp_list = [] for key , val in self . input_arguments . items (): argument_dict = {} argument_dict = val argument_dict . update ({ 'name' : key , 'value' : val . get ( 'default' )}) temp_list . append ( AtomicTestInput ( ** argument_dict )) self . input_arguments = temp_list if self . executor : executor_dict = self . executor if executor_dict . get ( 'name' ) == 'manual' : if not executor_dict . get ( 'command' ): executor_dict [ 'command' ] = '' self . executor = AtomicExecutor ( ** executor_dict ) executor_dict = None else : self . executor = [] if self . dependencies : dependency_list = [] for dependency in self . dependencies : dependency_list . append ( AtomicDependency ( ** dependency )) self . dependencies = dependency_list","title":"Data Models"},{"location":"models-ref/#atomic_operator.models.Config","text":"The main configuration class used across atomic-operator Raises: Type Description AtomicsFolderNotFound Raised when unable to find the provided atomics_path value Source code in atomic_operator/models.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @attr . s ( frozen = True ) class Config : \"\"\"The main configuration class used across atomic-operator Raises: AtomicsFolderNotFound: Raised when unable to find the provided atomics_path value \"\"\" atomics_path = attr . ib () check_prereqs = attr . ib ( default = False ) get_prereqs = attr . ib ( default = False ) cleanup = attr . ib ( default = False ) command_timeout = attr . ib ( default = 20 ) debug = attr . ib ( default = False ) prompt_for_input_args = attr . ib ( default = False ) kwargs = attr . ib ( default = {}) copy_source_files = attr . ib ( default = True ) def __attrs_post_init__ ( self ): object . __setattr__ ( self , 'atomics_path' , self . __get_abs_path ( self . atomics_path )) def __get_abs_path ( self , value ): return os . path . abspath ( os . path . expanduser ( os . path . expandvars ( value ))) @atomics_path . validator def validate_atomics_path ( self , attribute , value ): value = self . __get_abs_path ( value ) if not os . path . exists ( value ): raise AtomicsFolderNotFound ( 'Please provide a value for atomics_path that exists' )","title":"Config"},{"location":"models-ref/#atomic_operator.atomic.atomic.Atomic","text":"A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. Source code in atomic_operator/atomic/atomic.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @attr . s class Atomic : \"\"\"A single Atomic data structure. Each Atomic (technique) will contain a list of one or more AtomicTest objects. \"\"\" attack_technique = attr . ib () display_name = attr . ib () path = attr . ib () atomic_tests : typing . List [ AtomicTest ] = attr . ib () hosts : typing . List [ Host ] = attr . ib ( default = None ) def __attrs_post_init__ ( self ): if self . atomic_tests : test_list = [] for test in self . atomic_tests : test_list . append ( AtomicTest ( ** test )) self . atomic_tests = test_list","title":"Atomic"},{"location":"models-ref/#atomic_operator.atomic.atomictest.AtomicTest","text":"A single Atomic test object structure Returns: Name Type Description AtomicTest A single Atomic test object Source code in atomic_operator/atomic/atomictest.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @attr . s class AtomicTest : \"\"\"A single Atomic test object structure Returns: AtomicTest: A single Atomic test object \"\"\" name = attr . ib () description = attr . ib () supported_platforms = attr . ib () auto_generated_guid = attr . ib () executor = attr . ib () input_arguments = attr . ib ( default = None ) dependency_executor_name = attr . ib ( default = None ) dependencies : typing . List [ AtomicDependency ] = attr . ib ( default = []) def __attrs_post_init__ ( self ): if self . input_arguments : temp_list = [] for key , val in self . input_arguments . items (): argument_dict = {} argument_dict = val argument_dict . update ({ 'name' : key , 'value' : val . get ( 'default' )}) temp_list . append ( AtomicTestInput ( ** argument_dict )) self . input_arguments = temp_list if self . executor : executor_dict = self . executor if executor_dict . get ( 'name' ) == 'manual' : if not executor_dict . get ( 'command' ): executor_dict [ 'command' ] = '' self . executor = AtomicExecutor ( ** executor_dict ) executor_dict = None else : self . executor = [] if self . dependencies : dependency_list = [] for dependency in self . dependencies : dependency_list . append ( AtomicDependency ( ** dependency )) self . dependencies = dependency_list","title":"AtomicTest"},{"location":"running-tests-command-line/","text":"Running Atomic Tests In order to run tests using atomic-operator you must have one or more atomic tests . Selecting Tests to Run By default, atomic-operator will run all known tests within the provided directory. If you would like to specify specific tests then you must provide them as a list as input. Please note that techniques passed in but be separated by a , and NO spaces. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 Selecting Individual Atomic Tests You can select individual tests when you provide one or more specific techniques. For example running the following on the command line: atomic-operator run --techniques T1564.001 --select_tests Will prompt the user with a selection list of tests associated with that technique. A user can select one or more tests by using the space bar to highlight the desired test: Select Test(s) for Technique T1564.001 (Hide Artifacts: Hidden Files and Directories) * Create a hidden file in a hidden directory (61a782e5-9a19-40b5-8ba4-69a4b9f3d7be) Mac Hidden file (cddb9098-3b47-4e01-9d3b-6f5f323288a9) Create Windows System File with Attrib (f70974c8-c094-4574-b542-2c545af95a32) Create Windows Hidden File with Attrib (dadb792e-4358-4d8d-9207-b771faa0daa5) Hidden files (3b7015f2-3144-4205-b799-b05580621379) Hide a Directory (b115ecaf-3b24-4ed2-aefe-2fcb9db913d3) Show all hidden files (9a1ec7da-b892-449f-ad68-67066d04380c) Checking Dependencies There is an optional paramater that determines if atomic-operator should check dependencies or not. By default we do not check dependenicies but if set to True we will. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --check_dependicies True Checking of dependencies means we will run any defined prereq_command defined within the Atomic test. Get Prerequisities Another optional paramater deteremines if we retrieve or run any get_prereq_command values defined within the Atomic test. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --check_dependencies True --get_prereq_command True Setting this value to True means we will run that command but only if check_dependencies is set to True as well. Cleanup This optional parameter is by default set to False but if set to True then we will run any cleanup_command values defined within an Atomic test. atomic-operator run --atomics-path \"~/_Swimlane/ atomic-red-team\" --techniques T1560.002,T1560.001 --cleanup True Command Timeout The command_timeout parameter tells atomic-operator the duration (in seconds) to run a command without exiting that process. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --command_timeout 40 This defaults to 20 seconds but you can specify another value if needed. Debug The debug parameter will show additional details about the Atomic and tests (e.g. descriptions, etc.). atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --debug The default value is False and must be set to True to show this extra detail. Interactive Argument Inputs The prompt_for_input_args parameter will enable an interactive session and prompt you to enter arguments for any Atomic test(s) that require input arguments. You can simply provide a value or select to use the default defined within the Atomic test. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --prompt_for_input_args True The default value is False and must be set to True to prompt you for input values. kwargs If you choose not to set prompt_for_input_args to True then you can provide a dictionary of arguments in the kwargs input. This dictionary is only used for setting input argument values. For example, if you were running the Atomic test T1564.001 then would pass in a dictionary into the kwargs argument. Additional Input Arguments from Command Line If you do not want atomic-operator to prompt you for inputs you can simply run the following on the command line: atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1564.001 --kwargs '{\"filename\": \"myscript.py\"}'","title":"Running Tests on Command Line"},{"location":"running-tests-command-line/#running-atomic-tests","text":"In order to run tests using atomic-operator you must have one or more atomic tests .","title":"Running Atomic Tests"},{"location":"running-tests-command-line/#selecting-tests-to-run","text":"By default, atomic-operator will run all known tests within the provided directory. If you would like to specify specific tests then you must provide them as a list as input. Please note that techniques passed in but be separated by a , and NO spaces. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001","title":"Selecting Tests to Run"},{"location":"running-tests-command-line/#selecting-individual-atomic-tests","text":"You can select individual tests when you provide one or more specific techniques. For example running the following on the command line: atomic-operator run --techniques T1564.001 --select_tests Will prompt the user with a selection list of tests associated with that technique. A user can select one or more tests by using the space bar to highlight the desired test: Select Test(s) for Technique T1564.001 (Hide Artifacts: Hidden Files and Directories) * Create a hidden file in a hidden directory (61a782e5-9a19-40b5-8ba4-69a4b9f3d7be) Mac Hidden file (cddb9098-3b47-4e01-9d3b-6f5f323288a9) Create Windows System File with Attrib (f70974c8-c094-4574-b542-2c545af95a32) Create Windows Hidden File with Attrib (dadb792e-4358-4d8d-9207-b771faa0daa5) Hidden files (3b7015f2-3144-4205-b799-b05580621379) Hide a Directory (b115ecaf-3b24-4ed2-aefe-2fcb9db913d3) Show all hidden files (9a1ec7da-b892-449f-ad68-67066d04380c)","title":"Selecting Individual Atomic Tests"},{"location":"running-tests-command-line/#checking-dependencies","text":"There is an optional paramater that determines if atomic-operator should check dependencies or not. By default we do not check dependenicies but if set to True we will. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --check_dependicies True Checking of dependencies means we will run any defined prereq_command defined within the Atomic test.","title":"Checking Dependencies"},{"location":"running-tests-command-line/#get-prerequisities","text":"Another optional paramater deteremines if we retrieve or run any get_prereq_command values defined within the Atomic test. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --check_dependencies True --get_prereq_command True Setting this value to True means we will run that command but only if check_dependencies is set to True as well.","title":"Get Prerequisities"},{"location":"running-tests-command-line/#cleanup","text":"This optional parameter is by default set to False but if set to True then we will run any cleanup_command values defined within an Atomic test. atomic-operator run --atomics-path \"~/_Swimlane/ atomic-red-team\" --techniques T1560.002,T1560.001 --cleanup True","title":"Cleanup"},{"location":"running-tests-command-line/#command-timeout","text":"The command_timeout parameter tells atomic-operator the duration (in seconds) to run a command without exiting that process. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --command_timeout 40 This defaults to 20 seconds but you can specify another value if needed.","title":"Command Timeout"},{"location":"running-tests-command-line/#debug","text":"The debug parameter will show additional details about the Atomic and tests (e.g. descriptions, etc.). atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --debug The default value is False and must be set to True to show this extra detail.","title":"Debug"},{"location":"running-tests-command-line/#interactive-argument-inputs","text":"The prompt_for_input_args parameter will enable an interactive session and prompt you to enter arguments for any Atomic test(s) that require input arguments. You can simply provide a value or select to use the default defined within the Atomic test. atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1560.002,T1560.001 --prompt_for_input_args True The default value is False and must be set to True to prompt you for input values.","title":"Interactive Argument Inputs"},{"location":"running-tests-command-line/#kwargs","text":"If you choose not to set prompt_for_input_args to True then you can provide a dictionary of arguments in the kwargs input. This dictionary is only used for setting input argument values. For example, if you were running the Atomic test T1564.001 then would pass in a dictionary into the kwargs argument.","title":"kwargs"},{"location":"running-tests-command-line/#additional-input-arguments-from-command-line","text":"If you do not want atomic-operator to prompt you for inputs you can simply run the following on the command line: atomic-operator run --atomics-path \"~/_Swimlane/atomic-red-team\" --techniques T1564.001 --kwargs '{\"filename\": \"myscript.py\"}'","title":"Additional Input Arguments from Command Line"},{"location":"running-tests-script/","text":"Running Atomic Tests In order to run tests using atomic-operator you must have one or more atomic tests . Selecting Tests to Run By default, atomic-operator will run all known tests within the provided directory. from atomic_operator import AtomicOperator art = AtomicOperator() print(art.run(atomics_path='my_local_folder/atomic-red-team')) If you would like to specify specific tests then you must provide them as a list as input. Please note that techniques passed in but be separated by a , and NO spaces. from atomic_operator import AtomicOperator art = AtomicOperator() print(art.run( techniques='T1560.002', 'T1560.001'], atomics_path='my_local_folder/atomic-red-team' )) Checking Dependencies There is an optional paramater that determines if atomic-operator should check dependencies or not. By default we do not check dependenicies but if set to True we will. art.run( atomics_path='my_local_folder/atomic-red-team', check_dependencies=True ) check_dependencies means we will run any defined prereq_command defined within the Atomic test. Get Prerequisities Another optional paramater deteremines if we retrieve or run any get_prereq_command values defined within the Atomic test. art.run( atomics_path='my_local_folder/atomic-red-team', check_dependencies=True, get_prereq_command=True, ) Setting this value to True means we will run that command but only if check_dependencies is set to True as well. Cleanup This optional parameter is by default set to False but if set to True then we will run any cleanup_command values defined within an Atomic test. art.run( atomics_path='my_local_folder/atomic-red-team', cleanup=True ) Command Timeout The command_timeout parameter tells atomic-operator the duration (in seconds) to run a command without exiting that process. art.run( atomics_path='my_local_folder/atomic-red-team', command_timeout=40 ) This defaults to 20 seconds but you can specify another value if needed. Debug The debug parameter will show additional details about the Atomic and tests (e.g. descriptions, etc.). art.run( atomics_path='my_local_folder/atomic-red-team', debug=True ) The default value is False and must be set to True to show this extra detail. Interactive Argument Inputs The prompt_for_input_args parameter will enable an interactive session and prompt you to enter arguments for any Atomic test(s) that require input arguments. You can simply provide a value or select to use the default defined within the Atomic test. art.run( atomics_path='my_local_folder/atomic-red-team', prompt_for_input_args=True ) The default value is False and must be set to True to prompt you for input values. kwargs If you choose not to set prompt_for_input_args to True then you can provide a dictionary of arguments in the kwargs input. This dictionary is only used for setting input argument values. For example, if you were running the Atomic test T1564.001 then would pass in a dictionary into the kwargs argument. If you do not want atomic-operator to prompt you for inputs you can simply run the following on the command line: inputs = { 'filename': 'myscript.py' } art.run( atomics_path='my_local_folder/atomic-red-team', prompt_for_input_args=False, **inputs )","title":"Running Tests via Scripts"},{"location":"running-tests-script/#running-atomic-tests","text":"In order to run tests using atomic-operator you must have one or more atomic tests .","title":"Running Atomic Tests"},{"location":"running-tests-script/#selecting-tests-to-run","text":"By default, atomic-operator will run all known tests within the provided directory. from atomic_operator import AtomicOperator art = AtomicOperator() print(art.run(atomics_path='my_local_folder/atomic-red-team')) If you would like to specify specific tests then you must provide them as a list as input. Please note that techniques passed in but be separated by a , and NO spaces. from atomic_operator import AtomicOperator art = AtomicOperator() print(art.run( techniques='T1560.002', 'T1560.001'], atomics_path='my_local_folder/atomic-red-team' ))","title":"Selecting Tests to Run"},{"location":"running-tests-script/#checking-dependencies","text":"There is an optional paramater that determines if atomic-operator should check dependencies or not. By default we do not check dependenicies but if set to True we will. art.run( atomics_path='my_local_folder/atomic-red-team', check_dependencies=True ) check_dependencies means we will run any defined prereq_command defined within the Atomic test.","title":"Checking Dependencies"},{"location":"running-tests-script/#get-prerequisities","text":"Another optional paramater deteremines if we retrieve or run any get_prereq_command values defined within the Atomic test. art.run( atomics_path='my_local_folder/atomic-red-team', check_dependencies=True, get_prereq_command=True, ) Setting this value to True means we will run that command but only if check_dependencies is set to True as well.","title":"Get Prerequisities"},{"location":"running-tests-script/#cleanup","text":"This optional parameter is by default set to False but if set to True then we will run any cleanup_command values defined within an Atomic test. art.run( atomics_path='my_local_folder/atomic-red-team', cleanup=True )","title":"Cleanup"},{"location":"running-tests-script/#command-timeout","text":"The command_timeout parameter tells atomic-operator the duration (in seconds) to run a command without exiting that process. art.run( atomics_path='my_local_folder/atomic-red-team', command_timeout=40 ) This defaults to 20 seconds but you can specify another value if needed.","title":"Command Timeout"},{"location":"running-tests-script/#debug","text":"The debug parameter will show additional details about the Atomic and tests (e.g. descriptions, etc.). art.run( atomics_path='my_local_folder/atomic-red-team', debug=True ) The default value is False and must be set to True to show this extra detail.","title":"Debug"},{"location":"running-tests-script/#interactive-argument-inputs","text":"The prompt_for_input_args parameter will enable an interactive session and prompt you to enter arguments for any Atomic test(s) that require input arguments. You can simply provide a value or select to use the default defined within the Atomic test. art.run( atomics_path='my_local_folder/atomic-red-team', prompt_for_input_args=True ) The default value is False and must be set to True to prompt you for input values.","title":"Interactive Argument Inputs"},{"location":"running-tests-script/#kwargs","text":"If you choose not to set prompt_for_input_args to True then you can provide a dictionary of arguments in the kwargs input. This dictionary is only used for setting input argument values. For example, if you were running the Atomic test T1564.001 then would pass in a dictionary into the kwargs argument. If you do not want atomic-operator to prompt you for inputs you can simply run the following on the command line: inputs = { 'filename': 'myscript.py' } art.run( atomics_path='my_local_folder/atomic-red-team', prompt_for_input_args=False, **inputs )","title":"kwargs"},{"location":"windows-remote/","text":"Running Tests Remotely On Windows NOTE: To use this on your remote Windows machines, you need to do the following: Run from an elevated PowerShell prompt winrm quickconfig (type yes) Enable-PSRemoting (type yes) # Set start mode to automatic Set-Service WinRM -StartMode Automatic # Verify start mode and state - it should be running Get-WmiObject -Class win32_service | Where-Object {$_.name -like \"WinRM\"} Additionally you may need to specify the allowed host to remote into systems: # Trust hosts Set-Item 'WSMan:localhost\\client\\trustedhosts' -value * -Force NOTE: don't use the * for the value parameter in production - specify your Swimlane instance IP # Verify trusted hosts configuration Get-Item WSMan:\\localhost\\Client\\TrustedHosts Additional Troubleshooting #If you receive a timeout error or something like that, check and make sure that your remote Windows host network is set to Private and NOT public. You can change it using the following: # Get Network Profile Get-NetConnectionProfile # if the NetworkCategory is set to Public then run the following to set it to Private Set-NetConnectionProfile -InterfaceAlias Ethernet0 -NetworkCategory Private # try it again","title":"Running Tests Remotely On Windows"},{"location":"windows-remote/#running-tests-remotely-on-windows","text":"NOTE: To use this on your remote Windows machines, you need to do the following: Run from an elevated PowerShell prompt winrm quickconfig (type yes) Enable-PSRemoting (type yes) # Set start mode to automatic Set-Service WinRM -StartMode Automatic # Verify start mode and state - it should be running Get-WmiObject -Class win32_service | Where-Object {$_.name -like \"WinRM\"} Additionally you may need to specify the allowed host to remote into systems: # Trust hosts Set-Item 'WSMan:localhost\\client\\trustedhosts' -value * -Force NOTE: don't use the * for the value parameter in production - specify your Swimlane instance IP # Verify trusted hosts configuration Get-Item WSMan:\\localhost\\Client\\TrustedHosts Additional Troubleshooting #If you receive a timeout error or something like that, check and make sure that your remote Windows host network is set to Private and NOT public. You can change it using the following: # Get Network Profile Get-NetConnectionProfile # if the NetworkCategory is set to Public then run the following to set it to Private Set-NetConnectionProfile -InterfaceAlias Ethernet0 -NetworkCategory Private # try it again","title":"Running Tests Remotely On Windows"}]}